# 叁、進階應用

## 一、Vue.js 前端框架

### (一) Vue.js 基礎概念

Vue.js 是一個用於建立使用者介面的漸進式 JavaScript 框架，特別適合建立單頁面應用程式（SPA）。

#### 1. Vue.js 的特點
* 🚀 **漸進式框架**：可以逐步採用，不需要完全重寫現有專案
* 📦 **組件化開發**：將 UI 分解為可重複使用的組件
* 🎯 **響應式數據**：自動更新視圖當數據改變時
* 🛠️ **易學易用**：語法簡潔，學習曲線平緩
* 🔧 **工具生態**：豐富的官方和第三方工具支援

#### 2. Vue 實例與應用

| 概念 | 說明 | 範例 |
|------|------|------|
| Vue 應用 | 整個應用的根實例 | `createApp()` |
| 組件 | 可重複使用的 UI 單元 | `defineComponent()` |
| 模板 | 聲明式的 HTML 語法 | `<template>` |
| 響應式數據 | 自動追蹤的數據 | `ref()`, `reactive()` |

```javascript
// Vue 實例基本結構
import { createApp } from 'vue'

const app = createApp({
  data() {
    return {
      message: 'Hello Vue!',
      count: 0,
      isVisible: true
    }
  },
  methods: {
    increment() {
      this.count++
    },
    toggleVisibility() {
      this.isVisible = !this.isVisible
    }
  },
  computed: {
    doubleCount() {
      return this.count * 2
    }
  }
})

app.mount('#app')
```

#### 3. Vue 生命週期

| 階段 | 鉤子函數 | 說明 |
|------|----------|------|
| 創建 | `beforeCreate`, `created` | 組件實例創建前後 |
| 掛載 | `beforeMount`, `mounted` | DOM 掛載前後 |
| 更新 | `beforeUpdate`, `updated` | 數據更新前後 |
| 銷毀 | `beforeUnmount`, `unmounted` | 組件銷毀前後 |

### (二) 組件開發

組件是 Vue.js 最強大的功能之一，它讓我們可以將 UI 分割成獨立、可重複使用的部分。

#### 1. 單文件組件結構

| 部分 | 作用 | 說明 |
|------|------|------|
| `<template>` | 模板 | 定義組件的 HTML 結構 |
| `<script>` | 邏輯 | 定義組件的數據和方法 |
| `<style>` | 樣式 | 定義組件的 CSS 樣式 |

#### 2. 組件通信方式

| 方式 | 用途 | 範例 |
|------|------|------|
| Props | 父傳子 | `:title="parentTitle"` |
| Emit | 子傳父 | `$emit('update')` |
| Slots | 內容分發 | `<slot name="header">` |
| Provide/Inject | 跨層級 | `provide('key', value)` |

```vue
<!-- 單文件組件完整範例 -->
<template>
  <div class="user-card">
    <img :src="user.avatar" :alt="user.name" class="avatar">
    <div class="user-info">
      <h3>{{ user.name }}</h3>
      <p>{{ user.email }}</p>
      <span :class="statusClass">{{ user.status }}</span>
    </div>
    <div class="actions">
      <button @click="editUser" class="btn-edit">編輯</button>
      <button @click="deleteUser" class="btn-delete">刪除</button>
    </div>
  </div>
</template>

<script setup>
import { computed } from 'vue'

// Props 定義
const props = defineProps({
  user: {
    type: Object,
    required: true,
    validator(value) {
      return value.name && value.email
    }
  }
})

// Events 定義
const emit = defineEmits(['edit', 'delete'])

// 計算屬性
const statusClass = computed(() => {
  return {
    'status-active': props.user.status === 'active',
    'status-inactive': props.user.status === 'inactive'
  }
})

// 方法
const editUser = () => {
  emit('edit', props.user.id)
}

const deleteUser = () => {
  emit('delete', props.user.id)
}
</script>

<style scoped>
.user-card {
  display: flex;
  align-items: center;
  padding: 1rem;
  border: 1px solid #e1e5e9;
  border-radius: 8px;
  margin-bottom: 1rem;
}

.avatar {
  width: 60px;
  height: 60px;
  border-radius: 50%;
  margin-right: 1rem;
}

.user-info {
  flex: 1;
}

.status-active {
  color: #28a745;
}

.status-inactive {
  color: #6c757d;
}
</style>
```

### (三) 數據綁定與事件處理

Vue.js 提供了強大的數據綁定和事件處理機制，讓開發者能夠輕鬆創建互動式的使用者介面。

#### 1. 數據綁定類型

| 綁定類型 | 語法 | 說明 |
|----------|------|------|
| 插值綁定 | `{{ message }}` | 文本插值 |
| 屬性綁定 | `:href="url"` | 動態屬性 |
| 雙向綁定 | `v-model="value"` | 表單元素雙向同步 |
| 事件綁定 | `@click="handler"` | 事件監聽 |

#### 2. 指令系統

| 指令 | 作用 | 範例 |
|------|------|------|
| `v-if` | 條件渲染 | `v-if="isVisible"` |
| `v-for` | 列表渲染 | `v-for="item in items"` |
| `v-show` | 顯示/隱藏 | `v-show="isDisplay"` |
| `v-bind` | 屬性綁定 | `v-bind:class="className"` |
| `v-on` | 事件監聽 | `v-on:click="handleClick"` |

#### 3. 修飾符

| 類型 | 修飾符 | 說明 |
|------|--------|------|
| 事件修飾符 | `.stop`, `.prevent` | 阻止事件冒泡、預設行為 |
| 按鍵修飾符 | `.enter`, `.tab` | 特定按鍵觸發 |
| 表單修飾符 | `.lazy`, `.number` | 延遲同步、轉換類型 |

```vue
<template>
  <div class="data-binding-demo">
    <!-- 文本插值 -->
    <h1>{{ title }}</h1>
    <p>當前計數：{{ count }}</p>
    
    <!-- 屬性綁定 -->
    <img :src="imageUrl" :alt="imageAlt">
    <a :href="linkUrl" target="_blank">外部連結</a>
    
    <!-- 類別綁定 -->
    <div :class="{ active: isActive, 'text-danger': hasError }">
      動態類別
    </div>
    <div :class="[classA, { classB: isB }]">
      陣列語法
    </div>
    
    <!-- 樣式綁定 -->
    <div :style="{ color: textColor, fontSize: fontSize + 'px' }">
      動態樣式
    </div>
    
    <!-- 表單雙向綁定 -->
    <div class="form-section">
      <input v-model="message" placeholder="輸入訊息">
      <p>你輸入的是：{{ message }}</p>
      
      <input v-model.number="age" type="number" placeholder="年齡">
      <input v-model.lazy="description" placeholder="描述（失焦時更新）">
    </div>
    
    <!-- 事件處理 -->
    <div class="event-section">
      <button @click="increment">點擊增加</button>
      <button @click="decrement">點擊減少</button>
      <button @click.stop="handleStop">阻止冒泡</button>
      <input @keyup.enter="submitForm" placeholder="按 Enter 提交">
    </div>
    
    <!-- 條件渲染 -->
    <div v-if="showContent">
      <p>這是條件顯示的內容</p>
    </div>
    <div v-else>
      <p>替代內容</p>
    </div>
    
    <!-- 列表渲染 -->
    <ul>
      <li v-for="(item, index) in items" :key="item.id">
        {{ index + 1 }}. {{ item.name }} - {{ item.status }}
        <button @click="removeItem(index)">刪除</button>
      </li>
    </ul>
    
    <!-- 動態組件 -->
    <component :is="currentComponent" :data="componentData"></component>
  </div>
</template>

<script setup>
import { ref, reactive, computed, watch } from 'vue'

// 響應式數據
const title = ref('數據綁定示例')
const count = ref(0)
const message = ref('')
const age = ref(0)
const description = ref('')
const imageUrl = ref('https://via.placeholder.com/150')
const imageAlt = ref('示例圖片')
const linkUrl = ref('https://vuejs.org')
const isActive = ref(false)
const hasError = ref(false)
const classA = ref('class-a')
const isB = ref(true)
const textColor = ref('#42b883')
const fontSize = ref(16)
const showContent = ref(true)
const currentComponent = ref('ComponentA')
const componentData = ref({ message: 'Hello' })

const items = reactive([
  { id: 1, name: '項目 1', status: '完成' },
  { id: 2, name: '項目 2', status: '進行中' },
  { id: 3, name: '項目 3', status: '待開始' }
])

// 方法
const increment = () => {
  count.value++
  isActive.value = count.value > 5
}

const decrement = () => {
  count.value--
  hasError.value = count.value < 0
}

const handleStop = () => {
  console.log('阻止了事件冒泡')
}

const submitForm = () => {
  console.log('表單提交：', message.value)
}

const removeItem = (index) => {
  items.splice(index, 1)
}

// 監聽器
watch(count, (newVal, oldVal) => {
  console.log(`計數從 ${oldVal} 變為 ${newVal}`)
})
</script>
```

### (四) Composition API

Composition API 是 Vue 3 引入的新特性，提供了更靈活的邏輯組織方式，特別適合複雜組件的開發。

#### 1. Composition API 與 Options API 比較

| 特性 | Options API | Composition API |
|------|-------------|-----------------|
| 邏輯組織 | 按選項分組 | 按功能分組 |
| 程式碼重用 | Mixins | Composables |
| TypeScript 支援 | 有限 | 完整 |
| 學習曲線 | 較平緩 | 較陡峭 |
| 適用場景 | 簡單組件 | 複雜邏輯 |

#### 2. 核心響應式 API

| API | 用途 | 範例 |
|-----|------|------|
| `ref()` | 基本類型響應式 | `const count = ref(0)` |
| `reactive()` | 物件響應式 | `const state = reactive({})` |
| `computed()` | 計算屬性 | `const double = computed(() => count.value * 2)` |
| `watch()` | 監聽器 | `watch(count, (newVal) => {})` |

#### 3. 生命週期鉤子

| Options API | Composition API | 說明 |
|-------------|-----------------|------|
| `beforeCreate` | - | 不需要（setup 即相當於） |
| `created` | - | 不需要（setup 即相當於） |
| `beforeMount` | `onBeforeMount` | 掛載前 |
| `mounted` | `onMounted` | 掛載後 |
| `beforeUpdate` | `onBeforeUpdate` | 更新前 |
| `updated` | `onUpdated` | 更新後 |

```javascript
// Composition API 完整範例 (使用 script setup)
<script setup>
import { 
  ref, 
  reactive, 
  computed, 
  watch, 
  onMounted, 
  onUnmounted,
  nextTick 
} from 'vue'

// 1. 響應式數據
const count = ref(0)
const message = ref('Hello')
const user = reactive({
  name: 'John',
  age: 25,
  email: 'john@example.com'
})

// 2. 計算屬性
const doubleCount = computed(() => count.value * 2)
const fullInfo = computed(() => 
  `${user.name} (${user.age}) - ${user.email}`
)

// 3. 方法
const increment = () => {
  count.value++
}

const decrement = () => {
  if (count.value > 0) {
    count.value--
  }
}

const updateUser = (newData) => {
  Object.assign(user, newData)
}

// 4. 監聽器
watch(count, (newCount, oldCount) => {
  console.log(`Count changed from ${oldCount} to ${newCount}`)
  if (newCount > 10) {
    message.value = 'Count is getting high!'
  }
})

// 多個值監聽
watch([count, message], ([newCount, newMessage]) => {
  console.log(`Count: ${newCount}, Message: ${newMessage}`)
})

// 深度監聽物件
watch(
  () => user,
  (newUser) => {
    console.log('User updated:', newUser)
  },
  { deep: true }
)

// 5. 生命週期鉤子
onMounted(() => {
  console.log('Component mounted')
  // 初始化數據
  loadInitialData()
})

onUnmounted(() => {
  console.log('Component unmounted')
  // 清理工作
  cleanup()
})

// 6. 副作用函數
const loadInitialData = async () => {
  try {
    // 模擬 API 調用
    await new Promise(resolve => setTimeout(resolve, 1000))
    user.name = 'Loaded User'
    count.value = 5
  } catch (error) {
    console.error('Failed to load data:', error)
  }
}

const cleanup = () => {
  // 清理定時器、事件監聽器等
  if (timer.value) {
    clearInterval(timer.value)
  }
}

// 7. 定時器範例
const timer = ref(null)
const startTimer = () => {
  timer.value = setInterval(() => {
    increment()
  }, 1000)
}

const stopTimer = () => {
  if (timer.value) {
    clearInterval(timer.value)
    timer.value = null
  }
}
</script>
```

#### 4. 自定義 Composables

Composables 是 Composition API 的精髓，用於封裝和重用有狀態的邏輯。

:::spoiler Composables 範例
```javascript
// useCounter.js - 自定義計數器 composable
import { ref, computed } from 'vue'

export function useCounter(initialValue = 0) {
  const count = ref(initialValue)
  
  const increment = () => count.value++
  const decrement = () => count.value--
  const reset = () => count.value = initialValue
  
  const isEven = computed(() => count.value % 2 === 0)
  const isPositive = computed(() => count.value > 0)
  
  return {
    count,
    increment,
    decrement,
    reset,
    isEven,
    isPositive
  }
}

// useFetch.js - 資料獲取 composable
import { ref, isRef, unref, watchEffect } from 'vue'

export function useFetch(url) {
  const data = ref(null)
  const error = ref(null)
  const loading = ref(false)

  const doFetch = async () => {
    loading.value = true
    error.value = null
    
    try {
      const response = await fetch(unref(url))
      data.value = await response.json()
    } catch (err) {
      error.value = err
    } finally {
      loading.value = false
    }
  }

  if (isRef(url)) {
    watchEffect(doFetch)
  } else {
    doFetch()
  }

  return { data, error, loading, refresh: doFetch }
}

// 在組件中使用 (script setup 語法)
<script setup>
const { count, increment, isEven } = useCounter(10)
const { data, loading, error } = useFetch('/api/users')

// 直接使用，不需要 return
</script>
```
:::

#### 5. Composition API 最佳實踐

| 實踐 | 說明 | 範例 |
|------|------|------|
| 🎯 **邏輯分組** | 相關邏輯放在一起 | 將計數器邏輯單獨封裝 |
| 🔄 **Composables 重用** | 提取可重用邏輯 | `useCounter`, `useFetch` |
| 📝 **明確返回** | 清楚返回需要的數據 | 只返回模板需要的內容 |
| ⚠️ **響應式陷阱** | 注意 `.value` 語法 | `ref` 需要 `.value` |

## 二、Flask 後端框架

### (一) Flask 基礎概念

Flask 是一個輕量級的 Python Web 框架，以其簡潔性和靈活性而聞名，特別適合快速開發 Web 應用程式和 API。

#### 1. Flask 的特點
* 🚀 **微框架**：核心簡潔，可根據需求擴展
* 🎯 **靈活性**：不強制特定的目錄結構或組件
* 🛠️ **豐富擴展**：大量第三方擴展可選擇
* 📚 **易學習**：語法簡單，文檔完整
* 🔧 **高自定義**：可完全控制應用架構

#### 2. Flask 核心概念

| 概念 | 說明 | 範例 |
|------|------|------|
| 應用實例 | Flask 應用的核心對象 | `app = Flask(__name__)` |
| 路由 | URL 與視圖函數的映射 | `@app.route('/')` |
| 視圖函數 | 處理請求的函數 | `def index()` |
| 請求上下文 | 當前請求的相關信息 | `request.method` |
| 應用上下文 | 應用級別的信息 | `current_app` |

#### 3. HTTP 方法支援

| 方法 | 用途 | Flask 語法 |
|------|------|-----------|
| GET | 獲取資源 | `methods=['GET']` |
| POST | 創建資源 | `methods=['POST']` |
| PUT | 更新資源 | `methods=['PUT']` |
| DELETE | 刪除資源 | `methods=['DELETE']` |
| PATCH | 部分更新 | `methods=['PATCH']` |

### (二) 基本路由與視圖

路由是 Flask 應用的核心，它定義了 URL 與處理函數之間的對應關係。

#### 1. 路由裝飾器

| 裝飾器參數 | 說明 | 範例 |
|------------|------|------|
| `rule` | URL 規則 | `'/users/<int:id>'` |
| `methods` | 允許的 HTTP 方法 | `['GET', 'POST']` |
| `defaults` | 預設參數值 | `{'page': 1}` |
| `endpoint` | 端點名稱 | `'user_profile'` |

#### 2. URL 變數類型

| 類型 | 說明 | 範例 |
|------|------|------|
| `string` | 字串（預設） | `<username>` |
| `int` | 整數 | `<int:user_id>` |
| `float` | 浮點數 | `<float:price>` |
| `path` | 路徑（包含斜線） | `<path:subpath>` |
| `uuid` | UUID | `<uuid:token>` |

```python
from flask import Flask, jsonify, request, abort
import logging

app = Flask(__name__)

# 配置日誌
logging.basicConfig(level=logging.INFO)
logger = app.logger

# 基本路由
@app.route('/')
def hello_world():
    """首頁"""
    return {
        'message': 'Hello, World!',
        'version': '1.0.0',
        'status': 'running'
    }

# 帶參數的路由
@app.route('/users/<int:user_id>')
def get_user(user_id):
    """獲取特定用戶信息"""
    # 模擬用戶數據
    users = {
        1: {'name': 'Alice', 'email': 'alice@example.com'},
        2: {'name': 'Bob', 'email': 'bob@example.com'}
    }
    
    if user_id not in users:
        abort(404)
    
    return jsonify({
        'user_id': user_id,
        'user': users[user_id]
    })

# 多種 HTTP 方法
@app.route('/api/data', methods=['GET', 'POST'])
def handle_data():
    """處理數據的獲取和創建"""
    if request.method == 'GET':
        # 獲取數據
        page = request.args.get('page', 1, type=int)
        limit = request.args.get('limit', 10, type=int)
        
        return jsonify({
            'data': f'Page {page} data',
            'pagination': {
                'page': page,
                'limit': limit,
                'total': 100
            }
        })
    
    elif request.method == 'POST':
        # 創建數據
        if not request.is_json:
            return jsonify({'error': 'Content-Type must be application/json'}), 400
        
        data = request.get_json()
        
        # 簡單驗證
        if not data or 'name' not in data:
            return jsonify({'error': 'Name is required'}), 400
        
        # 模擬保存數據
        new_item = {
            'id': 123,
            'name': data['name'],
            'description': data.get('description', ''),
            'created_at': '2024-01-01T00:00:00Z'
        }
        
        logger.info(f"Created new item: {new_item}")
        return jsonify(new_item), 201

# 查詢參數處理
@app.route('/search')
def search():
    """搜索功能"""
    query = request.args.get('q', '')
    category = request.args.get('category', 'all')
    sort_by = request.args.get('sort', 'date')
    
    if not query:
        return jsonify({'error': 'Query parameter q is required'}), 400
    
    # 模擬搜索結果
    results = [
        {'id': 1, 'title': f'Result 1 for {query}', 'category': category},
        {'id': 2, 'title': f'Result 2 for {query}', 'category': category}
    ]
    
    return jsonify({
        'query': query,
        'category': category,
        'sort_by': sort_by,
        'results': results,
        'total': len(results)
    })

# 路徑參數
@app.route('/files/<path:filename>')
def serve_file(filename):
    """提供文件服務"""
    # 安全檢查
    if '..' in filename or filename.startswith('/'):
        abort(400)
    
    return jsonify({
        'filename': filename,
        'message': f'Serving file: {filename}'
    })

# 可選參數
@app.route('/blog')
@app.route('/blog/<int:page>')
def blog(page=1):
    """部落格文章列表"""
    posts_per_page = 5
    
    # 模擬文章數據
    all_posts = [f'Post {i}' for i in range(1, 51)]
    start = (page - 1) * posts_per_page
    end = start + posts_per_page
    posts = all_posts[start:end]
    
    return jsonify({
        'page': page,
        'posts': posts,
        'has_next': end < len(all_posts),
        'has_prev': page > 1,
        'total_pages': (len(all_posts) + posts_per_page - 1) // posts_per_page
    })

if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=5000)
```

### (三) 資料庫整合

Flask 與資料庫的整合是建立動態 Web 應用的重要部分，Flask-SQLAlchemy 是最常用的 ORM 擴展。

#### 1. SQLAlchemy 核心概念

| 概念 | 說明 | 範例 |
|------|------|------|
| Model | 數據模型類 | `class User(db.Model)` |
| Session | 數據庫會話 | `db.session` |
| Query | 查詢對象 | `User.query.filter_by()` |
| Migration | 數據庫遷移 | Flask-Migrate |

#### 2. 常用數據類型

| SQLAlchemy 類型 | Python 類型 | 說明 |
|------------------|-------------|------|
| `Integer` | `int` | 整數 |
| `String(size)` | `str` | 字串 |
| `Text` | `str` | 長文本 |
| `DateTime` | `datetime` | 日期時間 |
| `Boolean` | `bool` | 布林值 |
| `Float` | `float` | 浮點數 |

#### 3. 關係類型

| 關係 | 說明 | 範例 |
|------|------|------|
| 一對多 | 一個用戶多篇文章 | `User -> Posts` |
| 多對一 | 多篇文章屬於一個用戶 | `Posts -> User` |
| 一對一 | 用戶與個人資料 | `User -> Profile` |
| 多對多 | 用戶與角色 | `User <-> Role` |

```python
from flask import Flask, jsonify, request, abort
from flask_sqlalchemy import SQLAlchemy
from datetime import datetime
import os

app = Flask(__name__)

# 數據庫配置
basedir = os.path.abspath(os.path.dirname(__file__))
app.config['SQLALCHEMY_DATABASE_URI'] = f"sqlite:///{os.path.join(basedir, 'app.db')}"
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
app.config['SECRET_KEY'] = 'your-secret-key-here'

# 初始化數據庫
db = SQLAlchemy(app)

# 用戶模型
class User(db.Model):
    """用戶模型"""
    __tablename__ = 'users'
    
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False, index=True)
    email = db.Column(db.String(120), unique=True, nullable=False, index=True)
    password_hash = db.Column(db.String(128))
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    is_active = db.Column(db.Boolean, default=True)
    
    # 關係：一個用戶可以有多篇文章
    posts = db.relationship('Post', backref='author', lazy='dynamic', cascade='all, delete-orphan')
    
    def __repr__(self):
        return f'<User {self.username}>'
    
    def to_dict(self):
        """轉換為字典格式"""
        return {
            'id': self.id,
            'username': self.username,
            'email': self.email,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'is_active': self.is_active,
            'posts_count': self.posts.count()
        }

# 文章模型
class Post(db.Model):
    """文章模型"""
    __tablename__ = 'posts'
    
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(200), nullable=False)
    content = db.Column(db.Text)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    published = db.Column(db.Boolean, default=False)
    
    # 外鍵：關聯到用戶
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    
    def __repr__(self):
        return f'<Post {self.title}>'
    
    def to_dict(self):
        """轉換為字典格式"""
        return {
            'id': self.id,
            'title': self.title,
            'content': self.content,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'published': self.published,
            'author': self.author.username if self.author else None
        }

# 標籤模型（多對多關係示例）
post_tags = db.Table('post_tags',
    db.Column('post_id', db.Integer, db.ForeignKey('posts.id'), primary_key=True),
    db.Column('tag_id', db.Integer, db.ForeignKey('tags.id'), primary_key=True)
)

class Tag(db.Model):
    """標籤模型"""
    __tablename__ = 'tags'
    
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(50), unique=True, nullable=False)
    
    # 多對多關係
    posts = db.relationship('Post', secondary=post_tags, lazy='subquery',
                           backref=db.backref('tags', lazy=True))

# 數據庫操作路由
@app.route('/users', methods=['GET', 'POST'])
def handle_users():
    """處理用戶的獲取和創建"""
    if request.method == 'GET':
        # 獲取用戶列表
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 10, type=int)
        
        users = User.query.paginate(
            page=page, 
            per_page=per_page, 
            error_out=False
        )
        
        return jsonify({
            'users': [user.to_dict() for user in users.items],
            'pagination': {
                'page': page,
                'pages': users.pages,
                'per_page': per_page,
                'total': users.total,
                'has_next': users.has_next,
                'has_prev': users.has_prev
            }
        })
    
    elif request.method == 'POST':
        # 創建新用戶
        data = request.get_json()
        
        if not data:
            return jsonify({'error': 'No data provided'}), 400
        
        # 驗證必填字段
        required_fields = ['username', 'email']
        missing_fields = [field for field in required_fields if field not in data]
        if missing_fields:
            return jsonify({'error': f'Missing fields: {missing_fields}'}), 400
        
        # 檢查用戶名和郵箱是否已存在
        if User.query.filter_by(username=data['username']).first():
            return jsonify({'error': 'Username already exists'}), 409
        
        if User.query.filter_by(email=data['email']).first():
            return jsonify({'error': 'Email already exists'}), 409
        
        # 創建新用戶
        new_user = User(
            username=data['username'],
            email=data['email']
        )
        
        try:
            db.session.add(new_user)
            db.session.commit()
            return jsonify(new_user.to_dict()), 201
        except Exception as e:
            db.session.rollback()
            return jsonify({'error': 'Failed to create user'}), 500

@app.route('/users/<int:user_id>', methods=['GET', 'PUT', 'DELETE'])
def handle_user(user_id):
    """處理單個用戶的操作"""
    user = User.query.get_or_404(user_id)
    
    if request.method == 'GET':
        # 獲取用戶詳情
        user_data = user.to_dict()
        user_data['posts'] = [post.to_dict() for post in user.posts]
        return jsonify(user_data)
    
    elif request.method == 'PUT':
        # 更新用戶
        data = request.get_json()
        
        if 'username' in data:
            # 檢查用戶名是否被其他用戶使用
            existing_user = User.query.filter_by(username=data['username']).first()
            if existing_user and existing_user.id != user_id:
                return jsonify({'error': 'Username already exists'}), 409
            user.username = data['username']
        
        if 'email' in data:
            # 檢查郵箱是否被其他用戶使用
            existing_user = User.query.filter_by(email=data['email']).first()
            if existing_user and existing_user.id != user_id:
                return jsonify({'error': 'Email already exists'}), 409
            user.email = data['email']
        
        if 'is_active' in data:
            user.is_active = data['is_active']
        
        try:
            db.session.commit()
            return jsonify(user.to_dict())
        except Exception as e:
            db.session.rollback()
            return jsonify({'error': 'Failed to update user'}), 500
    
    elif request.method == 'DELETE':
        # 刪除用戶
        try:
            db.session.delete(user)
            db.session.commit()
            return jsonify({'message': 'User deleted successfully'})
        except Exception as e:
            db.session.rollback()
            return jsonify({'error': 'Failed to delete user'}), 500

# 查詢範例
@app.route('/users/search')
def search_users():
    """搜索用戶"""
    query = request.args.get('q', '')
    
    if not query:
        return jsonify({'error': 'Query parameter q is required'}), 400
    
    # 使用 OR 條件搜索用戶名和郵箱
    users = User.query.filter(
        db.or_(
            User.username.ilike(f'%{query}%'),
            User.email.ilike(f'%{query}%')
        )
    ).all()
    
    return jsonify({
        'query': query,
        'results': [user.to_dict() for user in users],
        'total': len(users)
    })

# 初始化數據庫
@app.before_first_request
def create_tables():
    """創建數據庫表"""
    db.create_all()
    
    # 創建一些示例數據
    if User.query.count() == 0:
        sample_users = [
            User(username='alice', email='alice@example.com'),
            User(username='bob', email='bob@example.com')
        ]
        
        for user in sample_users:
            db.session.add(user)
        
        db.session.commit()

if __name__ == '__main__':
    app.run(debug=True)
```

### (四) RESTful API 設計

RESTful API 是一種建構 Web 服務的架構風格，遵循 REST（Representational State Transfer）原則。

#### 1. REST 核心原則

| 原則 | 說明 | 實現方式 |
|------|------|----------|
| 無狀態 | 每個請求包含所有必要信息 | 不依賴 session |
| 資源導向 | 使用名詞而非動詞 | `/users` 而非 `/getUsers` |
| HTTP 方法 | 使用適當的 HTTP 動詞 | GET、POST、PUT、DELETE |
| 統一介面 | 一致的 URL 結構 | `/api/v1/resources/{id}` |

#### 2. HTTP 狀態碼使用

| 類別 | 範圍 | 常用狀態碼 | 說明 |
|------|------|------------|------|
| 成功 | 2xx | 200, 201, 204 | 請求成功 |
| 重定向 | 3xx | 301, 302 | 需要進一步操作 |
| 客戶端錯誤 | 4xx | 400, 401, 404 | 客戶端問題 |
| 服務器錯誤 | 5xx | 500, 502, 503 | 服務器問題 |

#### 3. RESTful URL 設計模式

| 操作 | HTTP 方法 | URL | 說明 |
|------|-----------|-----|------|
| 獲取列表 | GET | `/api/users` | 獲取所有用戶 |
| 獲取單個 | GET | `/api/users/123` | 獲取特定用戶 |
| 創建 | POST | `/api/users` | 創建新用戶 |
| 更新 | PUT | `/api/users/123` | 完整更新用戶 |
| 部分更新 | PATCH | `/api/users/123` | 部分更新用戶 |
| 刪除 | DELETE | `/api/users/123` | 刪除用戶 |

```python
from flask import Flask, jsonify, request, abort
from flask_restful import Resource, Api, reqparse
from werkzeug.exceptions import BadRequest
import logging

app = Flask(__name__)
api = Api(app)

# 配置日誌
logging.basicConfig(level=logging.INFO)
logger = app.logger

# 模擬數據存儲
items_db = {
    1: {'id': 1, 'name': 'Item 1', 'description': 'First item', 'category': 'A'},
    2: {'id': 2, 'name': 'Item 2', 'description': 'Second item', 'category': 'B'},
    3: {'id': 3, 'name': 'Item 3', 'description': 'Third item', 'category': 'A'}
}
next_id = 4

# 請求解析器
item_parser = reqparse.RequestParser()
item_parser.add_argument('name', type=str, required=True, help='Name is required')
item_parser.add_argument('description', type=str, default='')
item_parser.add_argument('category', type=str, default='default')

class ItemListResource(Resource):
    """項目列表資源"""
    
    def get(self):
        """獲取項目列表"""
        # 查詢參數
        category = request.args.get('category')
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 10, type=int)
        
        # 過濾數據
        items = list(items_db.values())
        if category:
            items = [item for item in items if item['category'] == category]
        
        # 分頁
        total = len(items)
        start = (page - 1) * per_page
        end = start + per_page
        paginated_items = items[start:end]
        
        return {
            'items': paginated_items,
            'pagination': {
                'page': page,
                'per_page': per_page,
                'total': total,
                'pages': (total + per_page - 1) // per_page,
                'has_next': end < total,
                'has_prev': page > 1
            }
        }
    
    def post(self):
        """創建新項目"""
        try:
            args = item_parser.parse_args()
            
            global next_id
            new_item = {
                'id': next_id,
                'name': args['name'],
                'description': args['description'],
                'category': args['category']
            }
            
            items_db[next_id] = new_item
            next_id += 1
            
            logger.info(f"Created item: {new_item}")
            return new_item, 201
            
        except BadRequest as e:
            return {'error': 'Invalid input', 'details': str(e)}, 400
        except Exception as e:
            logger.error(f"Error creating item: {e}")
            return {'error': 'Internal server error'}, 500

class ItemResource(Resource):
    """單個項目資源"""
    
    def get(self, item_id):
        """獲取單個項目"""
        if item_id not in items_db:
            abort(404, description="Item not found")
        
        return items_db[item_id]
    
    def put(self, item_id):
        """完整更新項目"""
        if item_id not in items_db:
            abort(404, description="Item not found")
        
        try:
            args = item_parser.parse_args()
            
            updated_item = {
                'id': item_id,
                'name': args['name'],
                'description': args['description'],
                'category': args['category']
            }
            
            items_db[item_id] = updated_item
            
            logger.info(f"Updated item {item_id}: {updated_item}")
            return updated_item
            
        except BadRequest as e:
            return {'error': 'Invalid input', 'details': str(e)}, 400
        except Exception as e:
            logger.error(f"Error updating item {item_id}: {e}")
            return {'error': 'Internal server error'}, 500
    
    def patch(self, item_id):
        """部分更新項目"""
        if item_id not in items_db:
            abort(404, description="Item not found")
        
        try:
            # 解析部分更新的數據
            patch_parser = reqparse.RequestParser()
            patch_parser.add_argument('name', type=str)
            patch_parser.add_argument('description', type=str)
            patch_parser.add_argument('category', type=str)
            args = patch_parser.parse_args()
            
            # 只更新提供的字段
            item = items_db[item_id]
            for key, value in args.items():
                if value is not None:
                    item[key] = value
            
            logger.info(f"Patched item {item_id}: {item}")
            return item
            
        except Exception as e:
            logger.error(f"Error patching item {item_id}: {e}")
            return {'error': 'Internal server error'}, 500
    
    def delete(self, item_id):
        """刪除項目"""
        if item_id not in items_db:
            abort(404, description="Item not found")
        
        try:
            deleted_item = items_db.pop(item_id)
            logger.info(f"Deleted item {item_id}: {deleted_item}")
            return {'message': 'Item deleted successfully'}, 204
            
        except Exception as e:
            logger.error(f"Error deleting item {item_id}: {e}")
            return {'error': 'Internal server error'}, 500

# 註冊資源
api.add_resource(ItemListResource, '/api/items')
api.add_resource(ItemResource, '/api/items/<int:item_id>')

# 搜索端點
@app.route('/api/items/search')
def search_items():
    """搜索項目"""
    query = request.args.get('q', '').lower()
    category = request.args.get('category')
    
    if not query:
        return jsonify({'error': 'Query parameter q is required'}), 400
    
    # 執行搜索
    results = []
    for item in items_db.values():
        if query in item['name'].lower() or query in item['description'].lower():
            if not category or item['category'] == category:
                results.append(item)
    
    return jsonify({
        'query': query,
        'category': category,
        'results': results,
        'total': len(results)
    })

if __name__ == '__main__':
    app.run(debug=True)
```

### (五) 錯誤處理與中間件

良好的錯誤處理是 Web 應用程式的重要組成部分，它能提供更好的用戶體驗和更容易的除錯。

#### 1. HTTP 錯誤處理策略

| 錯誤類型 | 處理方式 | 回應格式 |
|----------|----------|----------|
| 客戶端錯誤 | 明確錯誤訊息 | 詳細說明問題 |
| 服務器錯誤 | 記錄日誌 | 不暴露內部信息 |
| 驗證錯誤 | 字段級別回饋 | 具體驗證失敗原因 |
| 業務邏輯錯誤 | 業務規則說明 | 清晰的錯誤碼 |

#### 2. 自定義異常類

| 異常類型 | 用途 | HTTP 狀態碼 |
|----------|------|-------------|
| `ValidationError` | 數據驗證失敗 | 400 |
| `AuthenticationError` | 認證失敗 | 401 |
| `AuthorizationError` | 授權失敗 | 403 |
| `ResourceNotFoundError` | 資源不存在 | 404 |
| `BusinessLogicError` | 業務邏輯錯誤 | 422 |

```python
from flask import Flask, jsonify, request, abort
from werkzeug.exceptions import HTTPException
import traceback
import logging

app = Flask(__name__)

# 配置日誌
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = app.logger

# 自定義異常類
class APIException(Exception):
    """API 基礎異常類"""
    def __init__(self, message, status_code=400, payload=None):
        super().__init__(message)
        self.message = message
        self.status_code = status_code
        self.payload = payload

class ValidationError(APIException):
    """驗證錯誤"""
    def __init__(self, message, field=None):
        super().__init__(message, 400)
        self.field = field

class AuthenticationError(APIException):
    """認證錯誤"""
    def __init__(self, message="Authentication required"):
        super().__init__(message, 401)

class AuthorizationError(APIException):
    """授權錯誤"""
    def __init__(self, message="Insufficient permissions"):
        super().__init__(message, 403)

class ResourceNotFoundError(APIException):
    """資源不存在錯誤"""
    def __init__(self, resource="Resource", resource_id=None):
        message = f"{resource} not found"
        if resource_id:
            message += f" (ID: {resource_id})"
        super().__init__(message, 404)

class BusinessLogicError(APIException):
    """業務邏輯錯誤"""
    def __init__(self, message, error_code=None):
        super().__init__(message, 422)
        self.error_code = error_code

# 錯誤處理器
@app.errorhandler(APIException)
def handle_api_exception(error):
    """處理自定義 API 異常"""
    response = {
        'error': {
            'message': error.message,
            'type': error.__class__.__name__
        }
    }
    
    # 添加額外的錯誤信息
    if hasattr(error, 'field') and error.field:
        response['error']['field'] = error.field
    
    if hasattr(error, 'error_code') and error.error_code:
        response['error']['code'] = error.error_code
    
    if error.payload:
        response['error']['details'] = error.payload
    
    logger.warning(f"API Exception: {error.message}")
    return jsonify(response), error.status_code

@app.errorhandler(400)
def bad_request(error):
    """處理 400 錯誤"""
    return jsonify({
        'error': {
            'message': 'Bad request',
            'type': 'BadRequest',
            'details': str(error.description) if error.description else None
        }
    }), 400

@app.errorhandler(404)
def not_found(error):
    """處理 404 錯誤"""
    return jsonify({
        'error': {
            'message': 'Resource not found',
            'type': 'NotFound',
            'path': request.path
        }
    }), 404

@app.errorhandler(405)
def method_not_allowed(error):
    """處理 405 錯誤"""
    return jsonify({
        'error': {
            'message': f'Method {request.method} not allowed',
            'type': 'MethodNotAllowed',
            'allowed_methods': list(error.valid_methods) if hasattr(error, 'valid_methods') else None
        }
    }), 405

@app.errorhandler(500)
def internal_error(error):
    """處理 500 錯誤"""
    # 記錄完整的錯誤信息
    logger.error(f"Internal server error: {str(error)}")
    logger.error(traceback.format_exc())
    
    # 在生產環境中不應該暴露詳細的錯誤信息
    response = {
        'error': {
            'message': 'Internal server error',
            'type': 'InternalServerError'
        }
    }
    
    # 開發環境可以包含更多詳細信息
    if app.debug:
        response['error']['details'] = str(error)
    
    return jsonify(response), 500

# 請求驗證中間件
def validate_json():
    """驗證 JSON 請求"""
    if request.method in ['POST', 'PUT', 'PATCH']:
        if not request.is_json:
            raise ValidationError("Content-Type must be application/json")
        
        try:
            request.get_json(force=True)
        except Exception:
            raise ValidationError("Invalid JSON format")

# 認證中間件範例
def require_auth():
    """簡單的認證檢查"""
    auth_header = request.headers.get('Authorization')
    if not auth_header:
        raise AuthenticationError("Authorization header required")
    
    if not auth_header.startswith('Bearer '):
        raise AuthenticationError("Invalid authorization format")
    
    token = auth_header.split(' ')[1]
    if token != 'valid_token':  # 實際應用中應該驗證 JWT 或其他 token
        raise AuthenticationError("Invalid token")

# 業務邏輯範例
@app.route('/api/users', methods=['POST'])
def create_user():
    """創建用戶"""
    try:
        validate_json()
        data = request.get_json()
        
        # 數據驗證
        if not data.get('username'):
            raise ValidationError("Username is required", field="username")
        
        if not data.get('email'):
            raise ValidationError("Email is required", field="email")
        
        if len(data['username']) < 3:
            raise ValidationError("Username must be at least 3 characters", field="username")
        
        # 模擬檢查用戶是否已存在
        if data['username'] == 'existing_user':
            raise BusinessLogicError(
                "Username already exists",
                error_code="USER_EXISTS"
            )
        
        # 模擬創建用戶
        new_user = {
            'id': 123,
            'username': data['username'],
            'email': data['email'],
            'created_at': '2024-01-01T00:00:00Z'
        }
        
        return jsonify(new_user), 201
        
    except APIException:
        # 重新拋出 API 異常，讓錯誤處理器處理
        raise
    except Exception as e:
        # 捕獲所有其他異常並記錄
        logger.error(f"Unexpected error in create_user: {e}")
        raise APIException("An unexpected error occurred", 500)

@app.route('/api/protected')
def protected_resource():
    """需要認證的資源"""
    require_auth()
    return jsonify({'message': 'This is a protected resource'})

@app.route('/api/users/<int:user_id>')
def get_user(user_id):
    """獲取用戶信息"""
    # 模擬用戶不存在的情況
    if user_id == 999:
        raise ResourceNotFoundError("User", user_id)
    
    return jsonify({
        'id': user_id,
        'username': f'user_{user_id}',
        'email': f'user_{user_id}@example.com'
    })

# 全局錯誤處理中間件
@app.before_request
def log_request_info():
    """記錄請求信息"""
    logger.info(f"{request.method} {request.path} - {request.remote_addr}")

@app.after_request
def log_response_info(response):
    """記錄回應信息"""
    logger.info(f"Response: {response.status_code}")
    return response

# 健康檢查端點
@app.route('/health')
def health_check():
    """健康檢查"""
    return jsonify({
        'status': 'healthy',
        'timestamp': '2024-01-01T00:00:00Z'
    })

if __name__ == '__main__':
    app.run(debug=True)
```

## 三、前後端整合

### (一) API 介面設計與調用

前後端分離架構中，API 是前後端通信的橋樑，設計良好的 API 介面對於整個系統的可維護性至關重要。

#### 1. API 設計原則

| 原則 | 說明 | 範例 |
|------|------|------|
| 一致性 | 統一的命名和結構 | 所有時間格式都用 ISO 8601 |
| 可預測性 | 遵循標準慣例 | RESTful URL 設計 |
| 版本控制 | 支援 API 演進 | `/api/v1/users` |
| 文檔化 | 完整的 API 文檔 | Swagger/OpenAPI |

#### 2. 前端 HTTP 客戶端選擇

| 工具 | 特點 | 適用場景 |
|------|------|----------|
| Fetch API | 瀏覽器原生 | 簡單請求 |
| Axios | 功能豐富 | 複雜應用 |
| SWR/React Query | 數據緩存 | React 應用 |
| Vue Apollo | GraphQL | Vue + GraphQL |

```javascript
// 前端 API 調用完整範例
import axios from 'axios'

// 創建 Axios 實例
const api = axios.create({
  baseURL: process.env.VUE_APP_API_BASE_URL || 'http://localhost:5000/api',
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json'
  }
})

// 請求攔截器
api.interceptors.request.use(
  config => {
    // 添加認證 token
    const token = localStorage.getItem('auth_token')
    if (token) {
      config.headers.Authorization = `Bearer ${token}`
    }
    
    // 請求日誌
    console.log(`API Request: ${config.method?.toUpperCase()} ${config.url}`)
    return config
  },
  error => {
    console.error('Request error:', error)
    return Promise.reject(error)
  }
)

// 回應攔截器
api.interceptors.response.use(
  response => {
    console.log(`API Response: ${response.status} ${response.config.url}`)
    return response
  },
  error => {
    // 統一錯誤處理
    const { response } = error
    
    if (response) {
      switch (response.status) {
        case 401:
          // 未認證，跳轉到登入頁
          localStorage.removeItem('auth_token')
          window.location.href = '/login'
          break
        case 403:
          // 無權限
          console.error('Access denied')
          break
        case 404:
          // 資源不存在
          console.error('Resource not found')
          break
        case 422:
          // 業務邏輯錯誤
          console.error('Business logic error:', response.data.error?.message)
          break
        case 500:
          // 服務器錯誤
          console.error('Server error')
          break
        default:
          console.error('API Error:', response.data.error?.message || 'Unknown error')
      }
    } else {
      // 網路錯誤
      console.error('Network error:', error.message)
    }
    
    return Promise.reject(error)
  }
)

// API 服務類
class UserService {
  /**
   * 獲取用戶列表
   * @param {Object} params - 查詢參數
   * @returns {Promise} 用戶列表
   */
  static async getUsers(params = {}) {
    try {
      const response = await api.get('/users', { params })
      return {
        data: response.data.users,
        pagination: response.data.pagination,
        success: true
      }
    } catch (error) {
      return {
        data: [],
        error: error.response?.data?.error?.message || 'Failed to fetch users',
        success: false
      }
    }
  }

  /**
   * 獲取單個用戶
   * @param {number} userId - 用戶 ID
   * @returns {Promise} 用戶信息
   */
  static async getUser(userId) {
    try {
      const response = await api.get(`/users/${userId}`)
      return {
        data: response.data,
        success: true
      }
    } catch (error) {
      return {
        data: null,
        error: error.response?.data?.error?.message || `Failed to fetch user ${userId}`,
        success: false
      }
    }
  }

  /**
   * 創建用戶
   * @param {Object} userData - 用戶數據
   * @returns {Promise} 創建結果
   */
  static async createUser(userData) {
    try {
      const response = await api.post('/users', userData)
      return {
        data: response.data,
        success: true
      }
    } catch (error) {
      const errorData = error.response?.data?.error
      return {
        data: null,
        error: errorData?.message || 'Failed to create user',
        field: errorData?.field,
        success: false
      }
    }
  }

  /**
   * 更新用戶
   * @param {number} userId - 用戶 ID
   * @param {Object} userData - 更新數據
   * @returns {Promise} 更新結果
   */
  static async updateUser(userId, userData) {
    try {
      const response = await api.put(`/users/${userId}`, userData)
      return {
        data: response.data,
        success: true
      }
    } catch (error) {
      return {
        data: null,
        error: error.response?.data?.error?.message || `Failed to update user ${userId}`,
        success: false
      }
    }
  }

  /**
   * 刪除用戶
   * @param {number} userId - 用戶 ID
   * @returns {Promise} 刪除結果
   */
  static async deleteUser(userId) {
    try {
      await api.delete(`/users/${userId}`)
      return {
        success: true
      }
    } catch (error) {
      return {
        error: error.response?.data?.error?.message || `Failed to delete user ${userId}`,
        success: false
      }
    }
  }

  /**
   * 搜索用戶
   * @param {string} query - 搜索關鍵字
   * @returns {Promise} 搜索結果
   */
  static async searchUsers(query) {
    try {
      const response = await api.get('/users/search', {
        params: { q: query }
      })
      return {
        data: response.data.results,
        total: response.data.total,
        success: true
      }
    } catch (error) {
      return {
        data: [],
        error: error.response?.data?.error?.message || 'Failed to search users',
        success: false
      }
    }
  }
}

// 使用範例
export default UserService

// 在 Vue 組件中使用
export const useUserAPI = () => {
  const loading = ref(false)
  const error = ref(null)

  const fetchUsers = async (params) => {
    loading.value = true
    error.value = null
    
    const result = await UserService.getUsers(params)
    
    if (!result.success) {
      error.value = result.error
    }
    
    loading.value = false
    return result
  }

  const createUser = async (userData) => {
    loading.value = true
    error.value = null
    
    const result = await UserService.createUser(userData)
    
    if (!result.success) {
      error.value = result.error
    }
    
    loading.value = false
    return result
  }

  return {
    loading: readonly(loading),
    error: readonly(error),
    fetchUsers,
    createUser,
    // 其他方法...
  }
}
```

### (二) CORS 設定與安全

跨來源資源共享（CORS）是現代 Web 開發中的重要安全機制，需要正確配置以確保前後端通信正常。

#### 1. CORS 基本概念

| 概念 | 說明 | 範例 |
|------|------|------|
| 同源政策 | 瀏覽器安全限制 | 協議、域名、端口都相同 |
| 預檢請求 | OPTIONS 請求 | 複雜請求前的檢查 |
| 簡單請求 | 不觸發預檢 | GET、HEAD、POST（特定條件） |
| 憑證請求 | 包含 Cookie | withCredentials: true |

#### 2. CORS 標頭

| 標頭 | 作用 | 範例值 |
|------|------|--------|
| `Access-Control-Allow-Origin` | 允許的來源 | `*` 或 `https://example.com` |
| `Access-Control-Allow-Methods` | 允許的方法 | `GET, POST, PUT, DELETE` |
| `Access-Control-Allow-Headers` | 允許的標頭 | `Content-Type, Authorization` |
| `Access-Control-Allow-Credentials` | 允許憑證 | `true` |

```python
# Flask 後端 CORS 配置
from flask import Flask, jsonify
from flask_cors import CORS
import os

app = Flask(__name__)

# 開發環境 CORS 配置
if app.debug:
    CORS(app, 
         origins=['http://localhost:3000', 'http://127.0.0.1:3000'],
         allow_headers=['Content-Type', 'Authorization'],
         methods=['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
         supports_credentials=True)
else:
    # 生產環境更嚴格的配置
    allowed_origins = os.getenv('ALLOWED_ORIGINS', '').split(',')
    CORS(app,
         origins=allowed_origins,
         allow_headers=['Content-Type', 'Authorization'],
         methods=['GET', 'POST', 'PUT', 'DELETE'],
         supports_credentials=True)

# 手動 CORS 設定（更精細的控制）
@app.after_request
def after_request(response):
    """手動設定 CORS 標頭"""
    origin = request.headers.get('Origin')
    
    # 檢查來源是否在允許列表中
    allowed_origins = [
        'http://localhost:3000',
        'http://127.0.0.1:3000',
        'https://yourapp.com'
    ]
    
    if origin in allowed_origins:
        response.headers['Access-Control-Allow-Origin'] = origin
        response.headers['Access-Control-Allow-Credentials'] = 'true'
        response.headers['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE, OPTIONS'
        response.headers['Access-Control-Allow-Headers'] = 'Content-Type, Authorization, X-Requested-With'
    
    return response

# 處理預檢請求
@app.route('/api/<path:path>', methods=['OPTIONS'])
def handle_options(path):
    """處理 OPTIONS 預檢請求"""
    return '', 204
```

```javascript
// 前端 CORS 處理
const api = axios.create({
  baseURL: 'http://localhost:5000/api',
  withCredentials: true,  // 發送 cookies
  headers: {
    'Content-Type': 'application/json'
  }
})

// 處理 CORS 錯誤
api.interceptors.response.use(
  response => response,
  error => {
    if (error.code === 'ERR_NETWORK') {
      console.error('CORS error or network issue')
      // 顯示用戶友好的錯誤訊息
    }
    return Promise.reject(error)
  }
)
```

### (三) 檔案上傳處理

檔案上傳是 Web 應用中的常見需求，需要考慮安全性、效能和用戶體驗等多個方面。

#### 1. 檔案上傳安全考量

| 安全問題 | 防護措施 | 實現方式 |
|----------|----------|----------|
| 檔案類型驗證 | 白名單過濾 | 檢查副檔名和 MIME 類型 |
| 檔案大小限制 | 設定上限 | Flask: MAX_CONTENT_LENGTH |
| 檔名安全 | 清理檔名 | 使用 secure_filename() |
| 惡意程式碼 | 病毒掃描 | 第三方掃描服務 |
| 儲存位置 | 隔離存放 | 專用上傳目錄 |

#### 2. 上傳進度追蹤

| 方法 | 優點 | 缺點 |
|------|------|------|
| XMLHttpRequest | 原生支援 | 程式碼複雜 |
| Fetch API | 現代化 | 進度支援有限 |
| Axios | 內建進度回調 | 需要額外庫 |
| File API | 客戶端預覽 | 瀏覽器相容性 |

```python
# Flask 後端檔案上傳處理
from flask import Flask, request, jsonify, send_from_directory
from werkzeug.utils import secure_filename
from werkzeug.exceptions import RequestEntityTooLarge
import os
import uuid
import mimetypes
from pathlib import Path
import hashlib

app = Flask(__name__)

# 配置
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16MB 限制
app.config['UPLOAD_FOLDER'] = 'uploads'
app.config['ALLOWED_EXTENSIONS'] = {
    'images': {'png', 'jpg', 'jpeg', 'gif', 'webp'},
    'documents': {'pdf', 'doc', 'docx', 'xls', 'xlsx', 'txt'},
    'data': {'csv', 'json', 'xml'}
}

# 確保上傳目錄存在
os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)

def allowed_file(filename, category='images'):
    """檢查檔案是否允許上傳"""
    if '.' not in filename:
        return False
    
    extension = filename.rsplit('.', 1)[1].lower()
    return extension in app.config['ALLOWED_EXTENSIONS'].get(category, set())

def get_file_hash(file_path):
    """計算檔案 MD5 雜湊值"""
    hash_md5 = hashlib.md5()
    with open(file_path, "rb") as f:
        for chunk in iter(lambda: f.read(4096), b""):
            hash_md5.update(chunk)
    return hash_md5.hexdigest()

def validate_file_content(file_path, expected_type):
    """驗證檔案內容類型"""
    mime_type, _ = mimetypes.guess_type(file_path)
    
    type_mapping = {
        'images': ['image/'],
        'documents': ['application/pdf', 'application/msword', 'text/'],
        'data': ['text/csv', 'application/json', 'text/xml']
    }
    
    if expected_type in type_mapping:
        allowed_prefixes = type_mapping[expected_type]
        return any(mime_type and mime_type.startswith(prefix) for prefix in allowed_prefixes)
    
    return False

@app.route('/api/upload', methods=['POST'])
def upload_file():
    """處理檔案上傳"""
    try:
        # 檢查是否有檔案
        if 'file' not in request.files:
            return jsonify({'error': 'No file provided'}), 400
        
        file = request.files['file']
        category = request.form.get('category', 'images')
        
        # 檢查檔案是否選擇
        if file.filename == '':
            return jsonify({'error': 'No file selected'}), 400
        
        # 檢查檔案類型
        if not allowed_file(file.filename, category):
            allowed_exts = ', '.join(app.config['ALLOWED_EXTENSIONS'].get(category, []))
            return jsonify({
                'error': f'File type not allowed. Allowed types: {allowed_exts}'
            }), 400
        
        # 生成安全的檔名
        original_filename = secure_filename(file.filename)
        filename_without_ext = os.path.splitext(original_filename)[0]
        file_extension = os.path.splitext(original_filename)[1]
        
        # 使用 UUID 避免檔名衝突
        unique_filename = f"{filename_without_ext}_{uuid.uuid4().hex[:8]}{file_extension}"
        
        # 按類別創建子目錄
        category_folder = os.path.join(app.config['UPLOAD_FOLDER'], category)
        os.makedirs(category_folder, exist_ok=True)
        
        file_path = os.path.join(category_folder, unique_filename)
        
        # 保存檔案
        file.save(file_path)
        
        # 驗證檔案內容
        if not validate_file_content(file_path, category):
            os.remove(file_path)  # 刪除無效檔案
            return jsonify({'error': 'File content validation failed'}), 400
        
        # 計算檔案資訊
        file_size = os.path.getsize(file_path)
        file_hash = get_file_hash(file_path)
        
        # 檔案資訊
        file_info = {
            'id': uuid.uuid4().hex,
            'original_name': file.filename,
            'filename': unique_filename,
            'category': category,
            'size': file_size,
            'size_human': format_file_size(file_size),
            'hash': file_hash,
            'mime_type': mimetypes.guess_type(file_path)[0],
            'upload_time': datetime.utcnow().isoformat(),
            'url': f'/api/files/{category}/{unique_filename}'
        }
        
        # 這裡可以保存到資料庫
        # save_file_info_to_db(file_info)
        
        return jsonify({
            'message': 'File uploaded successfully',
            'file': file_info
        }), 201
        
    except RequestEntityTooLarge:
        return jsonify({'error': 'File too large'}), 413
    except Exception as e:
        app.logger.error(f"Upload error: {str(e)}")
        return jsonify({'error': 'Upload failed'}), 500

@app.route('/api/upload/multiple', methods=['POST'])
def upload_multiple_files():
    """處理多檔案上傳"""
    try:
        files = request.files.getlist('files')
        category = request.form.get('category', 'images')
        
        if not files:
            return jsonify({'error': 'No files provided'}), 400
        
        uploaded_files = []
        errors = []
        
        for file in files:
            if file.filename == '':
                continue
                
            if not allowed_file(file.filename, category):
                errors.append(f'{file.filename}: File type not allowed')
                continue
            
            try:
                # 使用相同的上傳邏輯
                # ... (省略重複代碼)
                
                uploaded_files.append({
                    'original_name': file.filename,
                    'filename': unique_filename,
                    'size': file_size
                })
                
            except Exception as e:
                errors.append(f'{file.filename}: {str(e)}')
        
        return jsonify({
            'message': f'Uploaded {len(uploaded_files)} files',
            'uploaded_files': uploaded_files,
            'errors': errors
        }), 201
        
    except Exception as e:
        app.logger.error(f"Multiple upload error: {str(e)}")
        return jsonify({'error': 'Upload failed'}), 500

@app.route('/api/files/<category>/<filename>')
def serve_file(category, filename):
    """提供檔案下載"""
    try:
        category_folder = os.path.join(app.config['UPLOAD_FOLDER'], category)
        return send_from_directory(category_folder, filename)
    except FileNotFoundError:
        return jsonify({'error': 'File not found'}), 404

def format_file_size(size_bytes):
    """格式化檔案大小"""
    if size_bytes == 0:
        return "0B"
    
    size_names = ["B", "KB", "MB", "GB"]
    i = 0
    while size_bytes >= 1024 and i < len(size_names) - 1:
        size_bytes /= 1024.0
        i += 1
    
    return f"{size_bytes:.1f}{size_names[i]}"

if __name__ == '__main__':
    app.run(debug=True)
```

```javascript
// 前端檔案上傳處理
class FileUploadService {
  constructor(apiBaseURL = '/api') {
    this.apiBaseURL = apiBaseURL
  }

  /**
   * 上傳單個檔案
   * @param {File} file - 檔案對象
   * @param {string} category - 檔案類別
   * @param {Function} onProgress - 進度回調
   * @returns {Promise} 上傳結果
   */
  async uploadFile(file, category = 'images', onProgress = null) {
    const formData = new FormData()
    formData.append('file', file)
    formData.append('category', category)

    try {
      const response = await axios.post(`${this.apiBaseURL}/upload`, formData, {
        headers: {
          'Content-Type': 'multipart/form-data'
        },
        onUploadProgress: (progressEvent) => {
          if (onProgress && progressEvent.total) {
            const progress = Math.round((progressEvent.loaded * 100) / progressEvent.total)
            onProgress(progress, progressEvent.loaded, progressEvent.total)
          }
        }
      })

      return {
        success: true,
        data: response.data
      }
    } catch (error) {
      return {
        success: false,
        error: error.response?.data?.error || 'Upload failed'
      }
    }
  }

  /**
   * 上傳多個檔案
   * @param {FileList} files - 檔案列表
   * @param {string} category - 檔案類別
   * @param {Function} onProgress - 進度回調
   * @returns {Promise} 上傳結果
   */
  async uploadMultipleFiles(files, category = 'images', onProgress = null) {
    const formData = new FormData()
    
    Array.from(files).forEach(file => {
      formData.append('files', file)
    })
    formData.append('category', category)

    try {
      const response = await axios.post(`${this.apiBaseURL}/upload/multiple`, formData, {
        headers: {
          'Content-Type': 'multipart/form-data'
        },
        onUploadProgress: (progressEvent) => {
          if (onProgress && progressEvent.total) {
            const progress = Math.round((progressEvent.loaded * 100) / progressEvent.total)
            onProgress(progress)
          }
        }
      })

      return {
        success: true,
        data: response.data
      }
    } catch (error) {
      return {
        success: false,
        error: error.response?.data?.error || 'Upload failed'
      }
    }
  }

  /**
   * 驗證檔案
   * @param {File} file - 檔案對象
   * @param {Object} options - 驗證選項
   * @returns {Object} 驗證結果
   */
  validateFile(file, options = {}) {
    const {
      maxSize = 16 * 1024 * 1024, // 16MB
      allowedTypes = ['image/jpeg', 'image/png', 'image/gif'],
      allowedExtensions = ['jpg', 'jpeg', 'png', 'gif']
    } = options

    const errors = []

    // 檢查檔案大小
    if (file.size > maxSize) {
      errors.push(`File size exceeds ${this.formatFileSize(maxSize)}`)
    }

    // 檢查檔案類型
    if (!allowedTypes.includes(file.type)) {
      errors.push(`File type ${file.type} not allowed`)
    }

    // 檢查副檔名
    const extension = file.name.split('.').pop()?.toLowerCase()
    if (extension && !allowedExtensions.includes(extension)) {
      errors.push(`File extension .${extension} not allowed`)
    }

    return {
      valid: errors.length === 0,
      errors
    }
  }

  /**
   * 格式化檔案大小
   * @param {number} bytes - 位元組數
   * @returns {string} 格式化後的大小
   */
  formatFileSize(bytes) {
    if (bytes === 0) return '0 B'
    
    const k = 1024
    const sizes = ['B', 'KB', 'MB', 'GB']
    const i = Math.floor(Math.log(bytes) / Math.log(k))
    
    return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i]
  }
}

// Vue 組件中使用
<script setup>
import { ref } from 'vue'

const uploadService = new FileUploadService()
const uploadProgress = ref(0)
const uploading = ref(false)
const selectedFiles = ref([])

const onFileSelect = (event) => {
  selectedFiles.value = Array.from(event.target.files)
  
  // 驗證檔案
  selectedFiles.value.forEach(file => {
    const validation = uploadService.validateFile(file)
    if (!validation.valid) {
      console.error(`${file.name}: ${validation.errors.join(', ')}`)
    }
  })
}

const uploadFiles = async () => {
  if (selectedFiles.value.length === 0) return

  uploading.value = true
  uploadProgress.value = 0

  try {
    const result = await uploadService.uploadMultipleFiles(
      selectedFiles.value,
      'images',
      (progress) => {
        uploadProgress.value = progress
      }
    )

    if (result.success) {
      console.log('Upload successful:', result.data)
      selectedFiles.value = []
      document.querySelector('input[type="file"]').value = ''
    } else {
      console.error('Upload failed:', result.error)
    }
  } catch (error) {
    console.error('Upload error:', error)
  } finally {
    uploading.value = false
    uploadProgress.value = 0
  }
}
</script>
```

### (四) 資料視覺化整合

將資料分析結果整合到前端進行視覺化是現代數據應用的重要組成部分，需要選擇合適的圖表庫並設計良好的數據流。

#### 1. 常用視覺化庫比較

| 圖表庫 | 特點 | 適用場景 | 學習難度 |
|--------|------|----------|----------|
| Chart.js | 輕量、簡單 | 基本圖表 | 低 |
| D3.js | 功能強大、靈活 | 複雜視覺化 | 高 |
| Plotly.js | 互動性強 | 科學數據 | 中 |
| ECharts | 豐富的圖表類型 | 商業儀表板 | 中 |
| Vue-ChartJS | Vue 整合 | Vue 專案 | 低 |

#### 2. 數據處理流程

| 階段 | 說明 | 責任方 |
|------|------|--------|
| 數據收集 | 從各種來源獲取原始數據 | 後端 |
| 數據清洗 | 處理缺失值、異常值 | 後端 |
| 數據轉換 | 轉換為視覺化格式 | 後端/前端 |
| 圖表渲染 | 生成互動式圖表 | 前端 |
| 用戶互動 | 篩選、縮放、導出 | 前端 |

```javascript
// Vue 組件中整合多種圖表庫
<template>
  <div class="dashboard">
    <!-- 控制面板 -->
    <div class="controls">
      <select v-model="selectedDataset" @change="updateCharts">
        <option value="sales">銷售數據</option>
        <option value="users">用戶數據</option>
        <option value="performance">效能數據</option>
      </select>
      
      <input 
        type="date" 
        v-model="startDate" 
        @change="updateCharts"
      >
      <input 
        type="date" 
        v-model="endDate" 
        @change="updateCharts"
      >
      
      <button @click="exportCharts">導出圖表</button>
    </div>

    <!-- 圖表容器 -->
    <div class="charts-grid">
      <!-- Plotly 圖表 -->
      <div class="chart-container">
        <h3>趨勢分析</h3>
        <div ref="trendChart" class="chart"></div>
      </div>

      <!-- Chart.js 圖表 -->
      <div class="chart-container">
        <h3>分類統計</h3>
        <canvas ref="categoryChart"></canvas>
      </div>

      <!-- ECharts 圖表 -->
      <div class="chart-container">
        <h3>地理分布</h3>
        <div ref="mapChart" class="chart"></div>
      </div>

      <!-- 自定義 D3 圖表 -->
      <div class="chart-container">
        <h3>關係網絡</h3>
        <div ref="networkChart" class="chart"></div>
      </div>
    </div>

    <!-- 數據表格 -->
    <div class="data-table">
      <h3>詳細數據</h3>
      <table>
        <thead>
          <tr>
            <th v-for="column in tableColumns" :key="column">
              {{ column }}
            </th>
          </tr>
        </thead>
        <tbody>
          <tr v-for="row in tableData" :key="row.id">
            <td v-for="column in tableColumns" :key="column">
              {{ row[column] }}
            </td>
          </tr>
        </tbody>
      </table>
    </div>
  </div>
</template>

<script setup>
import Plotly from 'plotly.js-dist'
import Chart from 'chart.js/auto'
import * as echarts from 'echarts'
import * as d3 from 'd3'
import { ref, onMounted, watch } from 'vue'

// 響應式數據
const selectedDataset = ref('sales')
const startDate = ref('')
const endDate = ref('')
const rawData = ref([])
const processedData = ref({})
const tableData = ref([])
const tableColumns = ref([])

// 圖表實例
const trendChart = ref(null)
const categoryChart = ref(null)
const mapChart = ref(null)
const networkChart = ref(null)

let chartInstances = {}

// 數據獲取和處理
const fetchData = async () => {
  try {
    const response = await fetch(`/api/analytics/${selectedDataset.value}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        start_date: startDate.value,
        end_date: endDate.value,
        filters: {
          // 其他篩選條件
        }
      })
    })
    
    const data = await response.json()
    rawData.value = data.raw_data
    processedData.value = data.processed_data
    tableData.value = data.table_data
    tableColumns.value = data.columns
    
  } catch (error) {
    console.error('數據獲取失敗:', error)
  }
}

// Plotly 趨勢圖
const createTrendChart = () => {
  if (!processedData.value.trend) return

  const traces = processedData.value.trend.map(series => ({
    x: series.dates,
    y: series.values,
    type: 'scatter',
    mode: 'lines+markers',
    name: series.name,
    line: { width: 2 }
  }))

  const layout = {
        title: '趨勢分析',
        xaxis: { 
          title: '時間',
          type: 'date'
        },
        yaxis: { title: '數值' },
        responsive: true,
        hovermode: 'x unified'
      }

      const config = {
        responsive: true,
        displayModeBar: true,
        modeBarButtonsToAdd: ['downloadSVG'],
        toImageButtonOptions: {
          format: 'png',
          filename: 'trend_chart',
          height: 500,
          width: 800
        }
      }

      Plotly.newPlot(trendChart.value, traces, layout, config)
    }

    // Chart.js 分類圖
    const createCategoryChart = () => {
      if (!processedData.value.categories) return

      const ctx = categoryChart.value.getContext('2d')
      
      if (chartInstances.categoryChart) {
        chartInstances.categoryChart.destroy()
      }

      chartInstances.categoryChart = new Chart(ctx, {
        type: 'doughnut',
        data: {
          labels: processedData.value.categories.labels,
          datasets: [{
            data: processedData.value.categories.values,
            backgroundColor: [
              '#FF6384', '#36A2EB', '#FFCE56',
              '#4BC0C0', '#9966FF', '#FF9F40'
            ],
            borderWidth: 2
          }]
        },
        options: {
          responsive: true,
          plugins: {
            legend: {
              position: 'bottom'
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  const total = context.dataset.data.reduce((a, b) => a + b, 0)
                  const percentage = ((context.raw / total) * 100).toFixed(1)
                  return `${context.label}: ${context.raw} (${percentage}%)`
                }
              }
            }
          }
        }
      })
    }

    // ECharts 地圖
    const createMapChart = () => {
      if (!processedData.value.geographic) return

      const myChart = echarts.init(mapChart.value)
      
      const option = {
        title: {
          text: '地理分布',
          left: 'center'
        },
        tooltip: {
          trigger: 'item',
          formatter: '{b}: {c}'
        },
        visualMap: {
          min: 0,
          max: Math.max(...processedData.value.geographic.values),
          left: 'left',
          top: 'bottom',
          text: ['高', '低'],
          calculable: true
        },
        series: [{
          name: '數據分布',
          type: 'map',
          map: 'world',
          roam: true,
          data: processedData.value.geographic.data
        }]
      }

      myChart.setOption(option)
      chartInstances.mapChart = myChart
    }

    // D3 網絡圖
    const createNetworkChart = () => {
      if (!processedData.value.network) return

      // 清除舊圖表
      d3.select(networkChart.value).selectAll("*").remove()

      const width = 600
      const height = 400

      const svg = d3.select(networkChart.value)
        .append("svg")
        .attr("width", width)
        .attr("height", height)

      const simulation = d3.forceSimulation(processedData.value.network.nodes)
        .force("link", d3.forceLink(processedData.value.network.links).id(d => d.id))
        .force("charge", d3.forceManyBody().strength(-300))
        .force("center", d3.forceCenter(width / 2, height / 2))

      const link = svg.append("g")
        .selectAll("line")
        .data(processedData.value.network.links)
        .enter().append("line")
        .attr("stroke", "#999")
        .attr("stroke-width", 2)

      const node = svg.append("g")
        .selectAll("circle")
        .data(processedData.value.network.nodes)
        .enter().append("circle")
        .attr("r", d => d.size || 5)
        .attr("fill", d => d.color || "#69b3a2")
        .call(d3.drag()
          .on("start", dragstarted)
          .on("drag", dragged)
          .on("end", dragended))

      // 添加標籤
      const label = svg.append("g")
        .selectAll("text")
        .data(processedData.value.network.nodes)
        .enter().append("text")
        .text(d => d.name)
        .attr("font-size", 12)
        .attr("dx", 12)
        .attr("dy", 4)

      simulation.on("tick", () => {
        link
          .attr("x1", d => d.source.x)
          .attr("y1", d => d.source.y)
          .attr("x2", d => d.target.x)
          .attr("y2", d => d.target.y)

        node
          .attr("cx", d => d.x)
          .attr("cy", d => d.y)

        label
          .attr("x", d => d.x)
          .attr("y", d => d.y)
      })

      function dragstarted(event, d) {
        if (!event.active) simulation.alphaTarget(0.3).restart()
        d.fx = d.x
        d.fy = d.y
      }

      function dragged(event, d) {
        d.fx = event.x
        d.fy = event.y
      }

      function dragended(event, d) {
        if (!event.active) simulation.alphaTarget(0)
        d.fx = null
        d.fy = null
      }
    }

    // 更新所有圖表
    const updateCharts = async () => {
      await fetchData()
      createTrendChart()
      createCategoryChart()
      createMapChart()
      createNetworkChart()
    }

    // 導出功能
    const exportCharts = () => {
      // 導出 Plotly 圖表
      Plotly.downloadImage(trendChart.value, {
        format: 'png',
        width: 800,
        height: 600,
        filename: 'trend_chart'
      })

      // 導出 Chart.js 圖表
      if (chartInstances.categoryChart) {
        const link = document.createElement('a')
        link.download = 'category_chart.png'
        link.href = chartInstances.categoryChart.toBase64Image()
        link.click()
      }

      // 導出 ECharts 圖表
      if (chartInstances.mapChart) {
        const link = document.createElement('a')
        link.download = 'map_chart.png'
        link.href = chartInstances.mapChart.getDataURL({
          type: 'png',
          pixelRatio: 2,
          backgroundColor: '#fff'
        })
        link.click()
      }
    }

    // 生命週期
    onMounted(() => {
      // 設定預設日期
      const today = new Date()
      const lastMonth = new Date(today.getFullYear(), today.getMonth() - 1, today.getDate())
      
      endDate.value = today.toISOString().split('T')[0]
      startDate.value = lastMonth.toISOString().split('T')[0]
      
      updateCharts()
    })

    // 監聽數據變化
    watch([selectedDataset, startDate, endDate], updateCharts)

    return {
      selectedDataset,
      startDate,
      endDate,
      tableData,
      tableColumns,
      trendChart,
      categoryChart,
      mapChart,
      networkChart,
      updateCharts,
      exportCharts
    }
  }
}
</script>

<style scoped>
.dashboard {
  padding: 20px;
}

.controls {
  display: flex;
  gap: 10px;
  margin-bottom: 20px;
  padding: 15px;
  background: #f5f5f5;
  border-radius: 8px;
}

.charts-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
  gap: 20px;
  margin-bottom: 30px;
}

.chart-container {
  background: white;
  padding: 15px;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.chart {
  height: 400px;
}

.data-table {
  background: white;
  padding: 15px;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

table {
  width: 100%;
  border-collapse: collapse;
}

th, td {
  padding: 8px 12px;
  text-align: left;
  border-bottom: 1px solid #ddd;
}

th {
  background-color: #f8f9fa;
  font-weight: 600;
}
</style>
```

### (五) 狀態管理

在複雜的前端應用中，狀態管理是組織數據流和保持應用一致性的關鍵，Vue 生態系統提供了多種狀態管理方案。

#### 1. 狀態管理方案比較

| 方案 | 適用場景 | 學習成本 | 功能特點 |
|------|----------|----------|----------|
| Props/Emit | 簡單組件通信 | 低 | Vue 內建 |
| Provide/Inject | 跨層級傳遞 | 低 | 依賴注入 |
| Vuex | 中大型應用 | 中 | 集中式狀態管理 |
| Pinia | 現代 Vue 應用 | 中 | TypeScript 友好 |
| Composition API | 局部狀態 | 低 | 邏輯復用 |

#### 2. Vuex 核心概念

| 概念 | 作用 | 特點 |
|------|------|------|
| State | 狀態存儲 | 響應式數據 |
| Getters | 計算屬性 | 派生狀態 |
| Mutations | 同步變更 | 可追蹤的變更 |
| Actions | 異步操作 | 業務邏輯 |
| Modules | 模組化 | 命名空間 |

#### 3. Pinia vs Vuex

| 特性 | Vuex | Pinia |
|------|------|-------|
| TypeScript | 有限支援 | 完整支援 |
| 語法 | 較複雜 | 更簡潔 |
| 開發工具 | Vue DevTools | Vue DevTools |
| 模組化 | 手動配置 | 自動模組化 |
| Vue 3 相容 | 需要 Vuex 4 | 原生支援 |

```javascript
// Vuex 完整狀態管理範例
import { createStore } from 'vuex'
import userModule from './modules/user'
import dataModule from './modules/data'
import uiModule from './modules/ui'

const store = createStore({
  modules: {
    user: userModule,
    data: dataModule,
    ui: uiModule
  },
  strict: process.env.NODE_ENV !== 'production'
})

// modules/user.js - 用戶模組
const userModule = {
  namespaced: true,
  
  state: () => ({
    currentUser: null,
    users: [],
    loading: false,
    error: null,
    preferences: {
      theme: 'light',
      language: 'zh-TW'
    }
  }),

  getters: {
    isAuthenticated: state => !!state.currentUser,
    
    userById: state => id => {
      return state.users.find(user => user.id === id)
    },
    
    activeUsers: state => {
      return state.users.filter(user => user.is_active)
    },
    
    userCount: (state, getters) => {
      return getters.activeUsers.length
    }
  },

  mutations: {
    SET_CURRENT_USER(state, user) {
      state.currentUser = user
    },
    
    SET_USERS(state, users) {
      state.users = users
    },
    
    ADD_USER(state, user) {
      state.users.push(user)
    },
    
    UPDATE_USER(state, updatedUser) {
      const index = state.users.findIndex(user => user.id === updatedUser.id)
      if (index !== -1) {
        state.users.splice(index, 1, updatedUser)
      }
    },
    
    REMOVE_USER(state, userId) {
      state.users = state.users.filter(user => user.id !== userId)
    },
    
    SET_LOADING(state, status) {
      state.loading = status
    },
    
    SET_ERROR(state, error) {
      state.error = error
    },
    
    CLEAR_ERROR(state) {
      state.error = null
    },
    
    UPDATE_PREFERENCES(state, preferences) {
      state.preferences = { ...state.preferences, ...preferences }
    }
  },

  actions: {
    async login({ commit, dispatch }, { username, password }) {
      commit('SET_LOADING', true)
      commit('CLEAR_ERROR')
      
      try {
        const response = await api.post('/auth/login', {
          username,
          password
        })
        
        const user = response.data.user
        const token = response.data.token
        
        // 保存 token
        localStorage.setItem('auth_token', token)
        
        commit('SET_CURRENT_USER', user)
        
        // 獲取用戶偏好設定
        await dispatch('loadUserPreferences')
        
        return { success: true, user }
        
      } catch (error) {
        const errorMessage = error.response?.data?.error?.message || '登入失敗'
        commit('SET_ERROR', errorMessage)
        return { success: false, error: errorMessage }
        
      } finally {
        commit('SET_LOADING', false)
      }
    },

    async logout({ commit }) {
      try {
        await api.post('/auth/logout')
      } catch (error) {
        console.warn('Logout request failed:', error)
      } finally {
        // 清除本地數據
        localStorage.removeItem('auth_token')
        commit('SET_CURRENT_USER', null)
        commit('CLEAR_ERROR')
      }
    },

    async fetchUsers({ commit, state }, { page = 1, search = '' } = {}) {
      if (state.loading) return
      
      commit('SET_LOADING', true)
      commit('CLEAR_ERROR')
      
      try {
        const response = await api.get('/users', {
          params: { page, search }
        })
        
        commit('SET_USERS', response.data.users)
        return response.data
        
      } catch (error) {
        const errorMessage = error.response?.data?.error?.message || '獲取用戶列表失敗'
        commit('SET_ERROR', errorMessage)
        throw error
        
      } finally {
        commit('SET_LOADING', false)
      }
    },

    async createUser({ commit, dispatch }, userData) {
      commit('SET_LOADING', true)
      commit('CLEAR_ERROR')
      
      try {
        const response = await api.post('/users', userData)
        const newUser = response.data
        
        commit('ADD_USER', newUser)
        
        // 顯示成功訊息
        dispatch('ui/showNotification', {
          type: 'success',
          message: '用戶創建成功'
        }, { root: true })
        
        return { success: true, user: newUser }
        
      } catch (error) {
        const errorMessage = error.response?.data?.error?.message || '創建用戶失敗'
        commit('SET_ERROR', errorMessage)
        
        dispatch('ui/showNotification', {
          type: 'error',
          message: errorMessage
        }, { root: true })
        
        return { success: false, error: errorMessage }
        
      } finally {
        commit('SET_LOADING', false)
      }
    },

    async updateUser({ commit, dispatch }, { userId, userData }) {
      commit('SET_LOADING', true)
      
      try {
        const response = await api.put(`/users/${userId}`, userData)
        const updatedUser = response.data
        
        commit('UPDATE_USER', updatedUser)
        
        dispatch('ui/showNotification', {
          type: 'success',
          message: '用戶更新成功'
        }, { root: true })
        
        return { success: true, user: updatedUser }
        
      } catch (error) {
        const errorMessage = error.response?.data?.error?.message || '更新用戶失敗'
        commit('SET_ERROR', errorMessage)
        return { success: false, error: errorMessage }
        
      } finally {
        commit('SET_LOADING', false)
      }
    },

    async deleteUser({ commit, dispatch }, userId) {
      commit('SET_LOADING', true)
      
      try {
        await api.delete(`/users/${userId}`)
        commit('REMOVE_USER', userId)
        
        dispatch('ui/showNotification', {
          type: 'success',
          message: '用戶刪除成功'
        }, { root: true })
        
        return { success: true }
        
      } catch (error) {
        const errorMessage = error.response?.data?.error?.message || '刪除用戶失敗'
        commit('SET_ERROR', errorMessage)
        return { success: false, error: errorMessage }
        
      } finally {
        commit('SET_LOADING', false)
      }
    },

    async loadUserPreferences({ commit, state }) {
      if (!state.currentUser) return
      
      try {
        const response = await api.get(`/users/${state.currentUser.id}/preferences`)
        commit('UPDATE_PREFERENCES', response.data)
        
      } catch (error) {
        console.warn('Failed to load user preferences:', error)
      }
    },

    async saveUserPreferences({ commit, state }, preferences) {
      if (!state.currentUser) return
      
      try {
        await api.put(`/users/${state.currentUser.id}/preferences`, preferences)
        commit('UPDATE_PREFERENCES', preferences)
        
      } catch (error) {
        console.error('Failed to save user preferences:', error)
        throw error
      }
    }
  }
}

// modules/data.js - 數據模組
const dataModule = {
  namespaced: true,
  
  state: () => ({
    datasets: [],
    currentDataset: null,
    analytics: {
      trends: [],
      categories: {},
      summary: {}
    },
    filters: {
      dateRange: {
        start: null,
        end: null
      },
      categories: [],
      searchQuery: ''
    },
    cache: new Map(),
    lastUpdated: null
  }),

  getters: {
    filteredData: state => {
      if (!state.currentDataset) return []
      
      let data = state.currentDataset.data
      
      // 日期過濾
      if (state.filters.dateRange.start && state.filters.dateRange.end) {
        data = data.filter(item => {
          const itemDate = new Date(item.date)
          return itemDate >= new Date(state.filters.dateRange.start) &&
                 itemDate <= new Date(state.filters.dateRange.end)
        })
      }
      
      // 分類過濾
      if (state.filters.categories.length > 0) {
        data = data.filter(item => 
          state.filters.categories.includes(item.category)
        )
      }
      
      // 搜索過濾
      if (state.filters.searchQuery) {
        const query = state.filters.searchQuery.toLowerCase()
        data = data.filter(item =>
          item.name.toLowerCase().includes(query) ||
          item.description.toLowerCase().includes(query)
        )
      }
      
      return data
    },

    datasetById: state => id => {
      return state.datasets.find(dataset => dataset.id === id)
    },

    isDataStale: state => {
      if (!state.lastUpdated) return true
      const fiveMinutesAgo = Date.now() - 5 * 60 * 1000
      return state.lastUpdated < fiveMinutesAgo
    }
  },

  mutations: {
    SET_DATASETS(state, datasets) {
      state.datasets = datasets
      state.lastUpdated = Date.now()
    },
    
    SET_CURRENT_DATASET(state, dataset) {
      state.currentDataset = dataset
    },
    
    SET_ANALYTICS(state, analytics) {
      state.analytics = analytics
    },
    
    UPDATE_FILTERS(state, filters) {
      state.filters = { ...state.filters, ...filters }
    },
    
    CLEAR_FILTERS(state) {
      state.filters = {
        dateRange: { start: null, end: null },
        categories: [],
        searchQuery: ''
      }
    },
    
    SET_CACHE(state, { key, data }) {
      state.cache.set(key, {
        data,
        timestamp: Date.now()
      })
    },
    
    CLEAR_CACHE(state) {
      state.cache.clear()
    }
  },

  actions: {
    async fetchDatasets({ commit, state }) {
      const cacheKey = 'datasets'
      const cached = state.cache.get(cacheKey)
      
      // 檢查緩存
      if (cached && (Date.now() - cached.timestamp) < 60000) {
        commit('SET_DATASETS', cached.data)
        return cached.data
      }
      
      try {
        const response = await api.get('/datasets')
        const datasets = response.data
        
        commit('SET_DATASETS', datasets)
        commit('SET_CACHE', { key: cacheKey, data: datasets })
        
        return datasets
        
      } catch (error) {
        console.error('Failed to fetch datasets:', error)
        throw error
      }
    },

    async loadDataset({ commit, dispatch }, datasetId) {
      try {
        const response = await api.get(`/datasets/${datasetId}`)
        const dataset = response.data
        
        commit('SET_CURRENT_DATASET', dataset)
        
        // 載入相關分析數據
        await dispatch('loadAnalytics', datasetId)
        
        return dataset
        
      } catch (error) {
        console.error('Failed to load dataset:', error)
        throw error
      }
    },

    async loadAnalytics({ commit }, datasetId) {
      try {
        const response = await api.get(`/datasets/${datasetId}/analytics`)
        commit('SET_ANALYTICS', response.data)
        
      } catch (error) {
        console.error('Failed to load analytics:', error)
      }
    },

    async refreshData({ dispatch, getters }) {
      if (getters.isDataStale) {
        await dispatch('fetchDatasets')
      }
    }
  }
}

// 在組件中使用 (script setup)
<script setup>
import { computed } from 'vue'
import { useStore } from 'vuex'
import { useRouter } from 'vue-router'

const store = useStore()
const router = useRouter()

// 計算屬性
const currentUser = computed(() => store.state.user.currentUser)
const loading = computed(() => store.state.user.loading)
const datasets = computed(() => store.state.data.datasets)
const analytics = computed(() => store.state.data.analytics)
const isAuthenticated = computed(() => store.getters['user/isAuthenticated'])
const activeUsers = computed(() => store.getters['user/activeUsers'])
const filteredData = computed(() => store.getters['data/filteredData'])

// 方法
const login = (credentials) => store.dispatch('user/login', credentials)
const fetchUsers = () => store.dispatch('user/fetchUsers')
const createUser = (userData) => store.dispatch('user/createUser', userData)
const fetchDatasets = () => store.dispatch('data/fetchDatasets')
const loadDataset = (datasetId) => store.dispatch('data/loadDataset', datasetId)

const handleLogin = async () => {
  const result = await login({
    username: username.value,
    password: password.value
  })
  
  if (result.success) {
    router.push('/dashboard')
  }
}

// 生命週期
onMounted(async () => {
  if (isAuthenticated.value) {
    await fetchDatasets()
  }
})
</script>

## 四、專案整合與最佳實踐

### (一) 專案架構設計

建立一個完整的前後端分離專案需要考慮多個層面的架構設計，確保可維護性、可擴展性和效能。

#### 1. 前端架構設計

| 層級 | 責任 | 技術選擇 |
|------|------|----------|
| 視圖層 | 用戶介面展示 | Vue 組件、CSS 框架 |
| 狀態層 | 數據狀態管理 | Vuex/Pinia |
| 服務層 | API 調用封裝 | Axios、HTTP 客戶端 |
| 工具層 | 通用工具函數 | Utils、Helpers |
| 配置層 | 環境配置 | 環境變數、配置文件 |

#### 2. 後端架構設計

| 層級 | 責任 | 技術選擇 |
|------|------|----------|
| 控制層 | 請求處理 | Flask 路由、控制器 |
| 服務層 | 業務邏輯 | Service 類 |
| 數據層 | 數據存取 | SQLAlchemy、Repository |
| 中間件 | 橫切關注點 | 認證、日誌、CORS |
| 配置層 | 應用配置 | Config 類、環境設定 |

#### 3. 專案目錄結構

```
project/
├── frontend/                    # 前端專案
│   ├── public/                 # 靜態資源
│   ├── src/
│   │   ├── assets/            # 資源文件
│   │   ├── components/        # 可重用組件
│   │   │   ├── common/        # 通用組件
│   │   │   ├── charts/        # 圖表組件
│   │   │   └── forms/         # 表單組件
│   │   ├── views/             # 頁面組件
│   │   ├── store/             # 狀態管理
│   │   │   ├── modules/       # Vuex 模組
│   │   │   └── index.js
│   │   ├── services/          # API 服務
│   │   ├── utils/             # 工具函數
│   │   ├── router/            # 路由配置
│   │   ├── plugins/           # 插件配置
│   │   └── main.js            # 入口文件
│   ├── tests/                 # 測試文件
│   ├── package.json
│   └── vue.config.js
├── backend/                    # 後端專案
│   ├── app/
│   │   ├── __init__.py        # 應用初始化
│   │   ├── models/            # 數據模型
│   │   ├── views/             # 視圖/控制器
│   │   ├── services/          # 業務邏輯
│   │   ├── utils/             # 工具函數
│   │   ├── middleware/        # 中間件
│   │   └── config.py          # 配置文件
│   ├── migrations/            # 數據庫遷移
│   ├── tests/                 # 測試文件
│   ├── requirements.txt       # 依賴列表
│   └── run.py                 # 啟動文件
├── database/                   # 數據庫相關
│   ├── seeds/                 # 種子數據
│   └── schema.sql             # 數據庫結構
├── docs/                      # 文檔
├── docker-compose.yml         # Docker 配置
└── README.md                  # 專案說明
```

### (二) 開發工作流程

#### 1. 開發環境設置

```bash
# 後端環境設置
cd backend
python -m venv venv
source venv/bin/activate  # Windows: venv\Scripts\activate
pip install -r requirements.txt

# 數據庫設置
flask db init
flask db migrate -m "Initial migration"
flask db upgrade

# 前端環境設置
cd frontend
npm install
npm run serve

# Docker 環境（可選）
docker-compose up -d
```

#### 2. 開發工作流

| 階段 | 任務 | 工具 |
|------|------|------|
| 規劃 | 需求分析、API 設計 | Swagger、Postman |
| 開發 | 編碼實現 | IDE、Git |
| 測試 | 單元測試、整合測試 | Jest、PyTest |
| 部署 | 建構、部署 | Docker、CI/CD |
| 監控 | 效能監控、錯誤追蹤 | 日誌、監控工具 |

### (三) 效能優化策略

#### 1. 前端優化

| 策略 | 實現方式 | 效果 |
|------|----------|------|
| 程式碼分割 | 動態 import | 減少初始載入時間 |
| 懶載入 | Vue 路由懶載入 | 按需載入 |
| 緩存策略 | HTTP 緩存、本地存儲 | 減少網路請求 |
| 圖片優化 | WebP、壓縮 | 減少檔案大小 |
| CDN | 靜態資源 CDN | 加速資源載入 |

```javascript
// 前端效能優化範例
// 1. 路由懶載入
const routes = [
  {
    path: '/dashboard',
    component: () => import('@/views/Dashboard.vue')
  },
  {
    path: '/analytics',
    component: () => import('@/views/Analytics.vue')
  }
]

// 2. 組件懶載入 (script setup)
<script setup>
import { defineAsyncComponent } from 'vue'

const DataChart = defineAsyncComponent(() => 
  import('@/components/charts/DataChart.vue')
)
</script>

// 3. 請求緩存
class CacheService {
  constructor() {
    this.cache = new Map()
    this.maxAge = 5 * 60 * 1000 // 5分鐘
  }

  get(key) {
    const item = this.cache.get(key)
    if (item && Date.now() - item.timestamp < this.maxAge) {
      return item.data
    }
    return null
  }

  set(key, data) {
    this.cache.set(key, {
      data,
      timestamp: Date.now()
    })
  }
}

// 4. 虛擬滾動（大列表優化）
<script setup>
import { RecycleScroller } from 'vue-virtual-scroller'

defineProps({
  items: {
    type: Array,
    required: true
  }
})
</script>

<template>
  <RecycleScroller
    class="scroller"
    :items="items"
    :item-size="60"
    key-field="id"
    v-slot="{ item }"
  >
    <div class="item">{{ item.name }}</div>
  </RecycleScroller>
</template>
```

#### 2. 後端優化

| 策略 | 實現方式 | 效果 |
|------|----------|------|
| 數據庫優化 | 索引、查詢優化 | 提升查詢速度 |
| 緩存 | Redis、記憶體緩存 | 減少數據庫壓力 |
| 分頁 | Limit/Offset | 減少數據傳輸 |
| 壓縮 | Gzip 壓縮 | 減少網路傳輸 |
| 非同步處理 | Celery、任務佇列 | 提升回應速度 |

```python
# 後端效能優化範例
from flask import Flask
from flask_caching import Cache
from flask_compress import Compress
import redis

app = Flask(__name__)

# 1. 啟用壓縮
Compress(app)

# 2. 設置緩存
app.config['CACHE_TYPE'] = 'redis'
app.config['CACHE_REDIS_URL'] = 'redis://localhost:6379/0'
cache = Cache(app)

# 3. 數據庫查詢優化
class UserService:
    @staticmethod
    @cache.memoize(timeout=300)  # 緩存5分鐘
    def get_user_stats():
        """獲取用戶統計信息（帶緩存）"""
        return db.session.query(
            func.count(User.id).label('total_users'),
            func.count(case([(User.is_active == True, 1)])).label('active_users')
        ).first()

    @staticmethod
    def get_users_paginated(page=1, per_page=20, search=None):
        """分頁獲取用戶"""
        query = User.query
        
        if search:
            query = query.filter(
                or_(
                    User.username.ilike(f'%{search}%'),
                    User.email.ilike(f'%{search}%')
                )
            )
        
        # 添加索引以優化查詢
        query = query.order_by(User.created_at.desc())
        
        return query.paginate(
            page=page,
            per_page=per_page,
            error_out=False
        )

# 4. 非同步任務處理
from celery import Celery

celery = Celery('app', broker='redis://localhost:6379/0')

@celery.task
def process_large_dataset(dataset_id):
    """非同步處理大型數據集"""
    # 長時間運行的任務
    pass

@app.route('/api/process-data', methods=['POST'])
def trigger_data_processing():
    data = request.get_json()
    task = process_large_dataset.delay(data['dataset_id'])
    return jsonify({'task_id': task.id})
```

### (四) 安全性考量

#### 1. 前端安全

| 威脅 | 防護措施 | 實現方式 |
|------|----------|----------|
| XSS 攻擊 | 輸入過濾、CSP | Vue 內建防護、CSP 標頭 |
| CSRF 攻擊 | CSRF Token | 請求標頭驗證 |
| 敏感數據洩露 | 不存儲敏感信息 | 移除 console.log |
| 依賴漏洞 | 定期更新 | npm audit |

#### 2. 後端安全

| 威脅 | 防護措施 | 實現方式 |
|------|----------|----------|
| SQL 注入 | 參數化查詢 | SQLAlchemy ORM |
| 認證繞過 | 強認證機制 | JWT、多因素認證 |
| 權限提升 | 最小權限原則 | RBAC 權限控制 |
| 數據洩露 | 加密存儲 | 密碼雜湊、數據加密 |

```python
# 安全性實現範例
from werkzeug.security import generate_password_hash, check_password_hash
from flask_jwt_extended import create_access_token, jwt_required, get_jwt_identity
import secrets

class SecurityService:
    @staticmethod
    def hash_password(password):
        """密碼雜湊"""
        return generate_password_hash(password, method='pbkdf2:sha256')
    
    @staticmethod
    def verify_password(password, password_hash):
        """密碼驗證"""
        return check_password_hash(password_hash, password)
    
    @staticmethod
    def generate_token(user_id, expires_delta=None):
        """生成 JWT Token"""
        additional_claims = {"user_id": user_id}
        return create_access_token(
            identity=user_id,
            additional_claims=additional_claims,
            expires_delta=expires_delta
        )

# 權限裝飾器
from functools import wraps

def require_permission(permission):
    def decorator(f):
        @wraps(f)
        @jwt_required()
        def decorated_function(*args, **kwargs):
            current_user_id = get_jwt_identity()
            if not UserService.has_permission(current_user_id, permission):
                return jsonify({'error': 'Insufficient permissions'}), 403
            return f(*args, **kwargs)
        return decorated_function
    return decorator

@app.route('/api/admin/users')
@require_permission('admin:users:read')
def admin_get_users():
    """需要管理員權限的端點"""
    pass
```

### (五) 測試策略

#### 1. 測試類型

| 測試類型 | 範圍 | 工具 |
|----------|------|------|
| 單元測試 | 單個函數/方法 | Jest、PyTest |
| 整合測試 | 模組間整合 | Vue Test Utils、Flask-Testing |
| E2E 測試 | 完整用戶流程 | Cypress、Selenium |
| API 測試 | API 端點 | Postman、Insomnia |

#### 2. 測試範例

```javascript
// 前端測試範例
import { mount } from '@vue/test-utils'
import UserList from '@/components/UserList.vue'

describe('UserList.vue', () => {
  test('displays users correctly', async () => {
    const users = [
      { id: 1, name: 'John', email: 'john@example.com' },
      { id: 2, name: 'Jane', email: 'jane@example.com' }
    ]
    
    const wrapper = mount(UserList, {
      props: { users }
    })
    
    expect(wrapper.findAll('.user-item')).toHaveLength(2)
    expect(wrapper.text()).toContain('John')
    expect(wrapper.text()).toContain('jane@example.com')
  })
})
```

```python
# 後端測試範例
import pytest
from app import create_app, db
from app.models import User

@pytest.fixture
def app():
    app = create_app('testing')
    with app.app_context():
        db.create_all()
        yield app
        db.drop_all()

@pytest.fixture
def client(app):
    return app.test_client()

def test_create_user(client):
    """測試用戶創建"""
    response = client.post('/api/users', json={
        'username': 'testuser',
        'email': 'test@example.com'
    })
    
    assert response.status_code == 201
    data = response.get_json()
    assert data['username'] == 'testuser'
    assert data['email'] == 'test@example.com'

def test_get_users(client):
    """測試用戶列表獲取"""
    # 先創建一些測試數據
    user1 = User(username='user1', email='user1@example.com')
    user2 = User(username='user2', email='user2@example.com')
    db.session.add_all([user1, user2])
    db.session.commit()
    
    response = client.get('/api/users')
    
    assert response.status_code == 200
    data = response.get_json()
    assert len(data['users']) == 2
```

### (六) 部署與維護

#### 1. 部署策略

| 環境 | 目的 | 配置 |
|------|------|------|
| 開發環境 | 日常開發 | 完整日誌、調試模式 |
| 測試環境 | 功能測試 | 模擬生產數據 |
| 預發環境 | 上線前驗證 | 生產配置 |
| 生產環境 | 用戶使用 | 高可用、監控 |

#### 2. Docker 部署

```dockerfile
# 前端 Dockerfile
FROM node:16-alpine as build
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .
RUN npm run build

FROM nginx:alpine
COPY --from=build /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/nginx.conf
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

```dockerfile
# 後端 Dockerfile
FROM python:3.9-slim
WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
COPY . .
EXPOSE 5000
CMD ["gunicorn", "--bind", "0.0.0.0:5000", "run:app"]
```

```yaml
# docker-compose.yml
version: '3.8'
services:
  frontend:
    build: ./frontend
    ports:
      - "3000:80"
    depends_on:
      - backend

  backend:
    build: ./backend
    ports:
      - "5000:5000"
    environment:
      - DATABASE_URL=postgresql://user:pass@db:5432/myapp
    depends_on:
      - db
      - redis

  db:
    image: postgres:13
    environment:
      POSTGRES_DB: myapp
      POSTGRES_USER: user
      POSTGRES_PASSWORD: pass
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:6-alpine
    ports:
      - "6379:6379"

volumes:
  postgres_data:
```

## 三、學習進階指南

### (一) 學習階段規劃

**🎯 進階開發者路徑（8-12週）**

**第1-2週：Vue.js 基礎與組件開發**
- 🚀 **框架入門**：Vue 3 基礎概念、響應式原理
- 🧩 **組件系統**：單文件組件、組件通信
- 🎨 **模板語法**：指令系統、事件處理
- 💡 **實作目標**：建立互動式待辦事項應用

```vue
<!-- 💡 第1週實作：互動式待辦事項應用 -->
<template>
  <div class="todo-app">
    <header class="app-header">
      <h1>📝 我的待辦事項</h1>
      <div class="stats">
        <span>總計: {{ todos.length }}</span>
        <span>已完成: {{ completedCount }}</span>
        <span>剩餘: {{ remainingCount }}</span>
      </div>
    </header>

    <div class="todo-input">
      <input
        v-model="newTodo"
        @keyup.enter="addTodo"
        placeholder="輸入新的待辦事項..."
        class="todo-field"
      >
      <button @click="addTodo" :disabled="!newTodo.trim()" class="add-btn">
        ➕ 新增
      </button>
    </div>

    <div class="filters">
      <button
        v-for="filter in filters"
        :key="filter.key"
        @click="currentFilter = filter.key"
        :class="{ active: currentFilter === filter.key }"
        class="filter-btn"
      >
        {{ filter.label }}
      </button>
    </div>

    <div class="todo-list">
      <TransitionGroup name="todo" tag="div">
        <TodoItem
          v-for="todo in filteredTodos"
          :key="todo.id"
          :todo="todo"
          @toggle="toggleTodo"
          @edit="editTodo"
          @delete="deleteTodo"
        />
      </TransitionGroup>
    </div>

    <div class="todo-actions" v-if="todos.length > 0">
      <button @click="clearCompleted" v-if="completedCount > 0" class="clear-btn">
        🗑️ 清除已完成 ({{ completedCount }})
      </button>
      <button @click="toggleAll" class="toggle-all-btn">
        {{ allCompleted ? '取消全選' : '全部完成' }}
      </button>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, watch } from 'vue'
import TodoItem from './components/TodoItem.vue'

// 響應式數據
const newTodo = ref('')
const currentFilter = ref('all')
const todos = ref([
  { id: 1, text: '學習 Vue 3 基礎', completed: false, priority: 'high', createdAt: new Date() },
  { id: 2, text: '建立第一個組件', completed: true, priority: 'medium', createdAt: new Date() },
  { id: 3, text: '理解響應式原理', completed: false, priority: 'high', createdAt: new Date() }
])

// 過濾器選項
const filters = [
  { key: 'all', label: '全部' },
  { key: 'active', label: '未完成' },
  { key: 'completed', label: '已完成' }
]

// 計算屬性
const completedCount = computed(() => todos.value.filter(todo => todo.completed).length)
const remainingCount = computed(() => todos.value.length - completedCount.value)
const allCompleted = computed(() => todos.value.length > 0 && completedCount.value === todos.value.length)

const filteredTodos = computed(() => {
  switch (currentFilter.value) {
    case 'active':
      return todos.value.filter(todo => !todo.completed)
    case 'completed':
      return todos.value.filter(todo => todo.completed)
    default:
      return todos.value
  }
})

// 方法
const addTodo = () => {
  const text = newTodo.value.trim()
  if (text) {
    todos.value.push({
      id: Date.now(),
      text,
      completed: false,
      priority: 'medium',
      createdAt: new Date()
    })
    newTodo.value = ''
  }
}

const toggleTodo = (id) => {
  const todo = todos.value.find(t => t.id === id)
  if (todo) {
    todo.completed = !todo.completed
  }
}

const editTodo = (id, newText) => {
  const todo = todos.value.find(t => t.id === id)
  if (todo) {
    todo.text = newText
  }
}

const deleteTodo = (id) => {
  const index = todos.value.findIndex(t => t.id === id)
  if (index > -1) {
    todos.value.splice(index, 1)
  }
}

const clearCompleted = () => {
  todos.value = todos.value.filter(todo => !todo.completed)
}

const toggleAll = () => {
  const targetState = !allCompleted.value
  todos.value.forEach(todo => {
    todo.completed = targetState
  })
}

// 監聽器 - 本地儲存
watch(todos, (newTodos) => {
  localStorage.setItem('todos', JSON.stringify(newTodos))
}, { deep: true })

// 載入本地資料
const loadTodos = () => {
  const saved = localStorage.getItem('todos')
  if (saved) {
    todos.value = JSON.parse(saved)
  }
}

// 初始化
loadTodos()
</script>

<style scoped>
.todo-app {
  max-width: 600px;
  margin: 0 auto;
  padding: 20px;
  font-family: 'Arial', '微軟正黑體', sans-serif;
}

.app-header {
  text-align: center;
  margin-bottom: 30px;
}

.app-header h1 {
  color: #2c3e50;
  margin-bottom: 10px;
}

.stats {
  display: flex;
  justify-content: center;
  gap: 20px;
  font-size: 14px;
  color: #7f8c8d;
}

.todo-input {
  display: flex;
  gap: 10px;
  margin-bottom: 20px;
}

.todo-field {
  flex: 1;
  padding: 12px;
  border: 2px solid #ecf0f1;
  border-radius: 8px;
  font-size: 16px;
  transition: border-color 0.3s;
}

.todo-field:focus {
  outline: none;
  border-color: #3498db;
}

.add-btn {
  padding: 12px 20px;
  background: #3498db;
  color: white;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  font-size: 16px;
  transition: background-color 0.3s;
}

.add-btn:hover:not(:disabled) {
  background: #2980b9;
}

.add-btn:disabled {
  background: #bdc3c7;
  cursor: not-allowed;
}

.filters {
  display: flex;
  justify-content: center;
  gap: 10px;
  margin-bottom: 20px;
}

.filter-btn {
  padding: 8px 16px;
  border: 2px solid #ecf0f1;
  background: white;
  border-radius: 20px;
  cursor: pointer;
  transition: all 0.3s;
}

.filter-btn.active {
  background: #3498db;
  color: white;
  border-color: #3498db;
}

.todo-list {
  min-height: 200px;
}

.todo-actions {
  display: flex;
  justify-content: space-between;
  margin-top: 20px;
  gap: 10px;
}

.clear-btn, .toggle-all-btn {
  padding: 10px 15px;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  transition: background-color 0.3s;
}

.clear-btn {
  background: #e74c3c;
  color: white;
}

.clear-btn:hover {
  background: #c0392b;
}

.toggle-all-btn {
  background: #2ecc71;
  color: white;
}

.toggle-all-btn:hover {
  background: #27ae60;
}

/* 動畫效果 */
.todo-enter-active, .todo-leave-active {
  transition: all 0.3s ease;
}

.todo-enter-from {
  opacity: 0;
  transform: translateY(-20px);
}

.todo-leave-to {
  opacity: 0;
  transform: translateX(20px);
}

@media (max-width: 768px) {
  .todo-app {
    padding: 10px;
  }
  
  .stats {
    flex-direction: column;
    gap: 5px;
  }
  
  .todo-input {
    flex-direction: column;
  }
  
  .filters {
    flex-wrap: wrap;
  }
  
  .todo-actions {
    flex-direction: column;
  }
}
</style>
```

**第3-4週：Flask 基礎與 API 開發**
- 🐍 **框架入門**：Flask 基礎概念、路由系統
- 🛠️ **API 設計**：RESTful API 開發規範
- 🗃️ **資料庫整合**：SQLAlchemy ORM 使用
- 💡 **實作目標**：建立待辦事項 API 後端

```python
# 💡 第3週實作：待辦事項 API 後端
from flask import Flask, request, jsonify
from flask_sqlalchemy import SQLAlchemy
from flask_cors import CORS
from datetime import datetime
import os
from werkzeug.exceptions import BadRequest, NotFound
import logging

# 應用程式設定
app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = os.environ.get('DATABASE_URL', 'sqlite:///todos.db')
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
app.config['SECRET_KEY'] = os.environ.get('SECRET_KEY', 'dev-secret-key')

# 擴展初始化
db = SQLAlchemy(app)
CORS(app)

# 設定日誌
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# 資料模型
class Todo(db.Model):
    """待辦事項模型"""
    id = db.Column(db.Integer, primary_key=True)
    text = db.Column(db.String(200), nullable=False)
    completed = db.Column(db.Boolean, default=False, nullable=False)
    priority = db.Column(db.String(10), default='medium', nullable=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow, nullable=False)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    due_date = db.Column(db.DateTime, nullable=True)
    category = db.Column(db.String(50), default='general')
    
    def to_dict(self):
        """轉換為字典格式"""
        return {
            'id': self.id,
            'text': self.text,
            'completed': self.completed,
            'priority': self.priority,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'updated_at': self.updated_at.isoformat() if self.updated_at else None,
            'due_date': self.due_date.isoformat() if self.due_date else None,
            'category': self.category
        }
    
    def __repr__(self):
        return f'<Todo {self.id}: {self.text[:20]}...>'

class Category(db.Model):
    """分類模型"""
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(50), unique=True, nullable=False)
    color = db.Column(db.String(7), default='#3498db')  # 十六進位顏色碼
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    
    def to_dict(self):
        return {
            'id': self.id,
            'name': self.name,
            'color': self.color,
            'created_at': self.created_at.isoformat() if self.created_at else None
        }

# 建立資料表
with app.app_context():
    db.create_all()
    
    # 建立預設分類
    if not Category.query.first():
        default_categories = [
            Category(name='工作', color='#e74c3c'),
            Category(name='學習', color='#3498db'),
            Category(name='生活', color='#2ecc71'),
            Category(name='其他', color='#95a5a6')
        ]
        for category in default_categories:
            db.session.add(category)
        db.session.commit()
        logger.info("建立預設分類")

# 錯誤處理
@app.errorhandler(BadRequest)
def handle_bad_request(e):
    return jsonify({'error': '請求格式錯誤', 'message': str(e)}), 400

@app.errorhandler(NotFound)
def handle_not_found(e):
    return jsonify({'error': '資源不存在', 'message': str(e)}), 404

@app.errorhandler(500)
def handle_internal_error(e):
    logger.error(f"內部伺服器錯誤: {str(e)}")
    return jsonify({'error': '內部伺服器錯誤'}), 500

# 輔助函數
def validate_todo_data(data):
    """驗證待辦事項資料"""
    if not data:
        raise BadRequest("請求內容不能為空")
    
    if not data.get('text', '').strip():
        raise BadRequest("待辦事項內容不能為空")
    
    if len(data.get('text', '')) > 200:
        raise BadRequest("待辦事項內容不能超過200字元")
    
    valid_priorities = ['low', 'medium', 'high']
    if data.get('priority') and data.get('priority') not in valid_priorities:
        raise BadRequest(f"優先級必須是以下之一: {', '.join(valid_priorities)}")
    
    return True

# API 路由
@app.route('/api/health', methods=['GET'])
def health_check():
    """健康檢查"""
    return jsonify({
        'status': 'healthy',
        'timestamp': datetime.utcnow().isoformat(),
        'version': '1.0.0'
    })

@app.route('/api/todos', methods=['GET'])
def get_todos():
    """獲取所有待辦事項"""
    try:
        # 查詢參數
        page = request.args.get('page', 1, type=int)
        per_page = min(request.args.get('per_page', 10, type=int), 100)  # 限制最大數量
        completed = request.args.get('completed')
        priority = request.args.get('priority')
        category = request.args.get('category')
        search = request.args.get('search')
        
        # 建立查詢
        query = Todo.query
        
        # 篩選條件
        if completed is not None:
            completed_bool = completed.lower() in ['true', '1', 'yes']
            query = query.filter(Todo.completed == completed_bool)
        
        if priority:
            query = query.filter(Todo.priority == priority)
        
        if category:
            query = query.filter(Todo.category == category)
        
        if search:
            query = query.filter(Todo.text.contains(search))
        
        # 排序和分頁
        query = query.order_by(Todo.created_at.desc())
        pagination = query.paginate(page=page, per_page=per_page, error_out=False)
        
        # 統計資訊
        stats = {
            'total': Todo.query.count(),
            'completed': Todo.query.filter(Todo.completed == True).count(),
            'pending': Todo.query.filter(Todo.completed == False).count(),
            'high_priority': Todo.query.filter(Todo.priority == 'high').count()
        }
        
        return jsonify({
            'todos': [todo.to_dict() for todo in pagination.items],
            'pagination': {
                'page': page,
                'per_page': per_page,
                'total': pagination.total,
                'pages': pagination.pages,
                'has_next': pagination.has_next,
                'has_prev': pagination.has_prev
            },
            'stats': stats
        })
        
    except Exception as e:
        logger.error(f"獲取待辦事項時發生錯誤: {str(e)}")
        return jsonify({'error': '獲取資料失敗'}), 500

@app.route('/api/todos', methods=['POST'])
def create_todo():
    """建立新的待辦事項"""
    try:
        data = request.get_json()
        validate_todo_data(data)
        
        # 解析到期日期
        due_date = None
        if data.get('due_date'):
            try:
                due_date = datetime.fromisoformat(data['due_date'].replace('Z', '+00:00'))
            except ValueError:
                raise BadRequest("到期日期格式錯誤")
        
        todo = Todo(
            text=data['text'].strip(),
            priority=data.get('priority', 'medium'),
            due_date=due_date,
            category=data.get('category', 'general')
        )
        
        db.session.add(todo)
        db.session.commit()
        
        logger.info(f"建立新待辦事項: {todo.id}")
        return jsonify(todo.to_dict()), 201
        
    except BadRequest:
        raise
    except Exception as e:
        db.session.rollback()
        logger.error(f"建立待辦事項時發生錯誤: {str(e)}")
        return jsonify({'error': '建立失敗'}), 500

@app.route('/api/todos/<int:todo_id>', methods=['GET'])
def get_todo(todo_id):
    """獲取特定待辦事項"""
    todo = Todo.query.get_or_404(todo_id)
    return jsonify(todo.to_dict())

@app.route('/api/todos/<int:todo_id>', methods=['PUT'])
def update_todo(todo_id):
    """更新待辦事項"""
    try:
        todo = Todo.query.get_or_404(todo_id)
        data = request.get_json()
        
        if not data:
            raise BadRequest("請求內容不能為空")
        
        # 更新欄位
        if 'text' in data:
            if not data['text'].strip():
                raise BadRequest("待辦事項內容不能為空")
            todo.text = data['text'].strip()
        
        if 'completed' in data:
            todo.completed = bool(data['completed'])
        
        if 'priority' in data:
            valid_priorities = ['low', 'medium', 'high']
            if data['priority'] not in valid_priorities:
                raise BadRequest(f"優先級必須是以下之一: {', '.join(valid_priorities)}")
            todo.priority = data['priority']
        
        if 'due_date' in data:
            if data['due_date']:
                try:
                    todo.due_date = datetime.fromisoformat(data['due_date'].replace('Z', '+00:00'))
                except ValueError:
                    raise BadRequest("到期日期格式錯誤")
            else:
                todo.due_date = None
        
        if 'category' in data:
            todo.category = data['category']
        
        todo.updated_at = datetime.utcnow()
        db.session.commit()
        
        logger.info(f"更新待辦事項: {todo.id}")
        return jsonify(todo.to_dict())
        
    except BadRequest:
        raise
    except Exception as e:
        db.session.rollback()
        logger.error(f"更新待辦事項時發生錯誤: {str(e)}")
        return jsonify({'error': '更新失敗'}), 500

@app.route('/api/todos/<int:todo_id>', methods=['DELETE'])
def delete_todo(todo_id):
    """刪除待辦事項"""
    try:
        todo = Todo.query.get_or_404(todo_id)
        db.session.delete(todo)
        db.session.commit()
        
        logger.info(f"刪除待辦事項: {todo_id}")
        return '', 204
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"刪除待辦事項時發生錯誤: {str(e)}")
        return jsonify({'error': '刪除失敗'}), 500

@app.route('/api/todos/bulk', methods=['PATCH'])
def bulk_update_todos():
    """批量更新待辦事項"""
    try:
        data = request.get_json()
        if not data or 'action' not in data:
            raise BadRequest("缺少必要參數")
        
        action = data['action']
        todo_ids = data.get('todo_ids', [])
        
        if not todo_ids:
            raise BadRequest("沒有指定要操作的待辦事項")
        
        todos = Todo.query.filter(Todo.id.in_(todo_ids)).all()
        
        if action == 'complete':
            for todo in todos:
                todo.completed = True
                todo.updated_at = datetime.utcnow()
        elif action == 'uncomplete':
            for todo in todos:
                todo.completed = False
                todo.updated_at = datetime.utcnow()
        elif action == 'delete':
            for todo in todos:
                db.session.delete(todo)
        else:
            raise BadRequest("無效的操作類型")
        
        db.session.commit()
        
        logger.info(f"批量操作 {action}: {len(todos)} 個項目")
        return jsonify({'message': f'成功處理 {len(todos)} 個項目'})
        
    except BadRequest:
        raise
    except Exception as e:
        db.session.rollback()
        logger.error(f"批量操作時發生錯誤: {str(e)}")
        return jsonify({'error': '批量操作失敗'}), 500

@app.route('/api/categories', methods=['GET'])
def get_categories():
    """獲取所有分類"""
    categories = Category.query.all()
    return jsonify([category.to_dict() for category in categories])

@app.route('/api/stats', methods=['GET'])
def get_stats():
    """獲取統計資訊"""
    try:
        stats = {
            'total_todos': Todo.query.count(),
            'completed_todos': Todo.query.filter(Todo.completed == True).count(),
            'pending_todos': Todo.query.filter(Todo.completed == False).count(),
            'priority_stats': {
                'high': Todo.query.filter(Todo.priority == 'high').count(),
                'medium': Todo.query.filter(Todo.priority == 'medium').count(),
                'low': Todo.query.filter(Todo.priority == 'low').count()
            },
            'overdue_todos': Todo.query.filter(
                Todo.due_date < datetime.utcnow(),
                Todo.completed == False
            ).count(),
            'today_todos': Todo.query.filter(
                Todo.created_at >= datetime.utcnow().date()
            ).count()
        }
        
        return jsonify(stats)
        
    except Exception as e:
        logger.error(f"獲取統計資訊時發生錯誤: {str(e)}")
        return jsonify({'error': '獲取統計失敗'}), 500

if __name__ == '__main__':
    port = int(os.environ.get('PORT', 5000))
    debug = os.environ.get('FLASK_DEBUG', 'False').lower() == 'true'
    
    app.run(host='0.0.0.0', port=port, debug=debug)
```

**第5-6週：前後端整合與狀態管理**
- 🔗 **API 串接**：Axios 使用、錯誤處理
- 📊 **狀態管理**：Pinia 全域狀態管理
- 🎨 **UI 組件庫**：整合現有 UI 框架
- 💡 **實作目標**：完成全功能待辦事項應用

**第7-8週：測試與部署**
- 🧪 **前端測試**：Vue Test Utils、Jest
- 🔍 **後端測試**：Pytest、測試覆蓋率
- 🚀 **部署實務**：Docker、雲端部署
- 💡 **實作目標**：完整的 CI/CD 流程

### (二) 實戰專案推薦

**🥉 初級專案：個人部落格系統**
```
專案目標：建立全端個人部落格平台
技術棧：Vue 3 + Flask + SQLite
功能規劃：
- ✍️ 文章發佈與編輯 (Markdown 支援)
- 🏷️ 標籤分類系統
- 💬 基礎評論功能
- 📱 響應式設計
- 🔍 文章搜尋功能
學習時間：4-5 週
重點技能：CRUD 操作、檔案上傳、權限控制
```

**🥈 中級專案：電商後台管理系統**
```
專案目標：建立功能完整的電商管理平台
技術棧：Vue 3 + Flask + PostgreSQL + Redis
功能規劃：
- 📦 商品管理 (新增、編輯、庫存)
- 👥 用戶管理與權限控制
- 📊 銷售數據分析與圖表
- 📷 圖片上傳與處理
- 🔐 JWT 身份驗證
- 📧 郵件通知系統
學習時間：6-8 週
重點技能：複雜狀態管理、權限系統、數據視覺化
```

**🥇 高級專案：即時協作平台**
```
專案目標：類似 Notion 的協作知識管理平台
技術棧：Vue 3 + Flask + WebSocket + Redis + PostgreSQL
功能規劃：
- 📝 富文本編輯器 (支援多種內容類型)
- 👥 多人即時協作編輯
- 🗂️ 層級式頁面組織
- 🔄 版本控制與歷史記錄
- 💬 即時評論與討論
- 🔗 分享與權限管理
- 📱 PWA 支援
學習時間：8-12 週
重點技能：即時通信、複雜UI組件、效能優化
```

### (三) 進階技能發展

**🚀 前端進階技術**
- **狀態管理進階**：Pinia 模式設計、插件開發
- **效能優化**：虛擬滾動、懶加載、代碼分割
- **測試策略**：單元測試、整合測試、E2E 測試
- **構建優化**：Vite 配置、打包優化、PWA

**🐍 後端進階技術**
- **微服務架構**：服務拆分、API Gateway
- **快取策略**：Redis 應用、查詢優化
- **安全性**：OAuth 2.0、HTTPS、安全頭設定
- **監控與日誌**：日誌聚合、效能監控、錯誤追蹤

**☁️ DevOps 與部署**
- **容器化**：Docker 多階段構建、Docker Compose
- **CI/CD**：GitHub Actions、自動化測試與部署
- **雲端服務**：AWS/Azure 部署、CDN 配置
- **監控運維**：健康檢查、自動擴縮容、備份策略

### (四) 學習資源與社群

**📚 官方文檔與教學**
- **Vue.js 官方文檔**：最權威的 Vue 3 學習資源
- **Flask 官方文檔**：完整的 Flask 開發指南
- **MDN Web Docs**：Web 標準技術參考
- **Python 官方教學**：深入的 Python 語言指南

**🎥 影片教學平台**
- **Vue Mastery**：Vue.js 專業課程
- **YouTube**：免費的技術教學頻道
- **Udemy/Coursera**：結構化線上課程
- **慕課網/極客時間**：中文技術教學平台

**💬 技術社群與論壇**
- **GitHub**：開源專案學習與貢獻
- **Stack Overflow**：技術問題解答
- **Vue.js 台灣社群**：本地技術交流
- **Python 台灣社群**：Python 開發者聚會

### (五) 職涯發展指南

**🎯 全端工程師發展路徑**

```
初級全端工程師 (0-2年)
├── 前端基礎 (HTML/CSS/JS)
├── 後端基礎 (Python/Flask)
├── 資料庫操作 (SQL)
├── 版本控制 (Git)
└── 基礎部署 (Linux/Docker)

中級全端工程師 (2-4年)
├── 框架精通 (Vue/React + 後端框架)
├── 資料庫設計與優化
├── API 設計與微服務
├── 測試與品質保證
├── 雲端平台使用
└── DevOps 基礎

高級全端工程師 (4+年)
├── 系統架構設計
├── 效能調優專家
├── 技術選型與評估
├── 團隊技術領導
├── 產品思維與商業理解
└── 新技術探索與採用
```

**💼 職業機會與薪資發展**

| 職級 | 年資 | 技能要求 | 薪資範圍 (台灣) |
|------|------|----------|----------------|
| 初級工程師 | 0-2年 | 基礎技術棧 | 40-70萬 |
| 中級工程師 | 2-4年 | 獨立開發能力 | 70-120萬 |
| 高級工程師 | 4-7年 | 技術深度與廣度 | 120-200萬 |
| 技術主管 | 7+年 | 團隊領導 | 200萬以上 |

**🚀 持續學習建議**

1. **技術深度 vs 廣度平衡**
   - 選擇 1-2 個技術棧深入專精
   - 保持對新技術的敏感度和學習能力
   - 定期參與技術社群和會議

2. **實作與理論並重**
   - 每月至少完成一個小專案
   - 閱讀優秀開源專案的程式碼
   - 撰寫技術部落格分享學習心得

3. **軟技能發展**
   - 溝通協作能力
   - 問題分析與解決能力
   - 專案管理與時間規劃

### (六) 學習成效檢核

**📋 階段性檢核指標**

**Vue.js 掌握度檢核**
- [ ] 能夠建立響應式單頁應用
- [ ] 熟練使用 Composition API
- [ ] 理解並實作組件通信
- [ ] 能夠進行狀態管理 (Pinia)
- [ ] 具備測試與除錯能力

**Flask 開發能力檢核**
- [ ] 能夠設計 RESTful API
- [ ] 熟練使用 ORM 進行資料庫操作
- [ ] 實作身份驗證與授權
- [ ] 具備錯誤處理與日誌記錄能力
- [ ] 能夠編寫單元測試

**全端整合能力檢核**
- [ ] 能夠完成前後端數據流設計
- [ ] 具備 API 設計與文檔撰寫能力
- [ ] 理解並實作安全性最佳實踐
- [ ] 能夠進行效能優化
- [ ] 具備部署與維護能力

**專業技能檢核**
- [ ] 能夠獨立規劃與執行完整專案
- [ ] 具備程式碼品質管控能力
- [ ] 能夠進行技術選型與架構設計
- [ ] 具備團隊協作與溝通能力
- [ ] 保持持續學習與技術更新

記住，成為優秀的全端工程師需要**持續實作**和**深度思考**！🚀 每個專案都是成長的機會，每個挑戰都是提升的契機。保持好奇心，勇於嘗試新技術，並且不斷反思和改進自己的代碼品質。

通過這個完整的第三階段進階應用指南，您已經掌握了從前端 Vue.js 開發到後端 Flask 設計，再到前後端整合的完整技術棧。這些知識將幫助您建立功能完整、效能優良、安全可靠的現代 Web 應用程式。

技術學習是一個持續的過程，建議在實際專案中應用這些知識，並根據專案需求選擇合適的技術方案。同時，保持對新技術的關注，不斷更新和完善您的技能樹。
